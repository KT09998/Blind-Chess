<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>æš—æ£‹ - çµ‚æ¥µæŠ€èƒ½å¤§äº‚é¬¥ (é›»è…¦ç‰ˆå„ªåŒ–)</title>
    <style>
        :root {
            --board-bg: #e6cca0;
            --grid-line: #5c4033;
            --piece-red: #c0392b;
            --piece-black: #2c3e50;
            --valid-capture: rgba(231, 76, 60, 0.6);
            --valid-skill: rgba(52, 152, 219, 0.6);
            --valid-cannon-skill: rgba(230, 126, 34, 0.7);
            --valid-storm-skill: rgba(142, 68, 173, 0.6);
            --valid-gold-skill: rgba(241, 196, 15, 0.8);
            --valid-nitro-skill: rgba(0, 206, 201, 0.7);
            --valid-dark-attack: rgba(230, 126, 34, 0.6);
            --ui-bg: #2c3e50;
            --panel-bg: rgba(0, 0, 0, 0.3);
            --safe-bottom: env(safe-area-inset-bottom, 20px);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, "bikai", "KaiTi", "DFKai-SB", serif;
            background-color: var(--ui-bg);
            margin: 0; padding: 0;
            display: flex; flex-direction: column; align-items: center; 
            /* Full viewport height */
            height: 100vh; height: 100dvh; width: 100vw;
            overflow: hidden; color: white;
            user-select: none; -webkit-user-select: none;
            touch-action: manipulation;
        }

        /* --- Screens --- */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(44, 62, 80, 0.98);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 1000; transition: opacity 0.3s;
        }
        .hidden-screen { display: none !important; opacity: 0; pointer-events: none; }

        h1 { font-size: 2rem; margin-bottom: 1.5rem; color: #f1c40f; text-shadow: 2px 2px 0 #000; text-align: center; }
        
        .menu-btn {
            padding: 15px 0; width: 80%; max-width: 300px;
            font-size: 1.2rem; margin: 10px 0; border: none; border-radius: 50px;
            background: #e74c3c; color: white; cursor: pointer; box-shadow: 0 5px 0 #c0392b;
            font-family: inherit; font-weight: bold;
        }
        .menu-btn:active { transform: translateY(5px); box-shadow: none; }
        .btn-blue { background: #3498db; box-shadow: 0 5px 0 #2980b9; }
        .btn-green { background: #2ecc71; box-shadow: 0 5px 0 #27ae60; }

        /* --- Main Layout Wrapper --- */
        /* This wrapper handles the flex direction switch between Mobile (Column) and Desktop (Row) */
        #main-wrapper {
            display: flex;
            flex-direction: column;
            width: 100%;
            flex: 1; /* Take all available space above controls */
            min-height: 0; /* Important for nested flex scroll */
            padding: 5px;
            box-sizing: border-box;
            justify-content: center;
            align-items: center;
        }

        /* --- Side Panels (Graveyards) --- */
        .side-panel {
            flex: 0 0 auto;
            display: flex;
            flex-direction: column;
            justify-content: center; align-items: center;
            padding: 5px;
            box-sizing: border-box;
            z-index: 10;
            width: 100%; /* Mobile default */
        }

        #status-bar { display: flex; justify-content: center; padding: 5px 0; width: 100%; }

        .turn-indicator {
            padding: 5px 20px; border-radius: 20px; background: #444; color: #ccc;
            border: 2px solid transparent; min-width: 100px; text-align: center;
            font-size: 1rem; font-weight: bold; box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        .turn-indicator.active-red { background: var(--piece-red); color: white; border-color: #e74c3c; box-shadow: 0 0 10px var(--piece-red); }
        .turn-indicator.active-black { background: black; color: white; border-color: #7f8c8d; box-shadow: 0 0 10px white; }

        .graveyard-box {
            background: var(--panel-bg); border: 1px solid #5c4033; border-radius: 8px;
            display: flex; gap: 5px; padding: 5px; box-sizing: border-box;
            width: 100%; height: 45px; /* Mobile fixed height */
            overflow-x: auto; overflow-y: hidden; align-items: center;
        }
        .graveyard-box::-webkit-scrollbar { height: 0px; width: 0px; }

        .graveyard-piece {
            width: 32px; height: 32px; border-radius: 50%; flex-shrink: 0;
            background-color: #f3e5ab; color: #000;
            display: flex; justify-content: center; align-items: center;
            font-size: 18px; font-weight: bold; border: 2px solid #8b4513; position: relative;
        }
        .graveyard-piece.red { color: var(--piece-red); border-color: var(--piece-red); }
        .graveyard-piece.black { color: var(--piece-black); border-color: var(--piece-black); }
        .graveyard-piece.ff-dead { border: 3px double; font-size: 20px; }
        .graveyard-piece.ff-dead::after { content: 'ğŸ’€'; position: absolute; font-size: 12px; bottom: -4px; right: -4px; }

        /* --- Board Area --- */
        .board-container {
            flex: 1; /* Grow to fill space */
            min-height: 0; min-width: 0; /* Allow shrinking */
            display: flex; justify-content: center; align-items: center;
            padding: 5px; 
            width: 100%;
        }

        #board {
            /* Strict Aspect Ratio 1:2 */
            aspect-ratio: 4/8;
            /* Try to fill height first, but limit by width */
            height: 100%;
            width: auto;
            max-width: 100%;
            
            background-color: var(--board-bg);
            border: 4px solid #5c4033; border-radius: 8px;
            display: grid; grid-template-columns: repeat(4, 1fr); grid-template-rows: repeat(8, 1fr);
            gap: 1px; box-shadow: 0 5px 20px rgba(0,0,0,0.6); position: relative;
        }

        .cell {
            position: relative; border: 1px solid rgba(92, 64, 51, 0.2);
            display: flex; justify-content: center; align-items: center; cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .piece {
            width: 90%; height: 90%; border-radius: 50%;
            background: #f3e5ab; border: 2px solid #8b4513;
            box-shadow: inset 2px 2px 5px rgba(255,255,255,0.4), 1px 1px 3px rgba(0,0,0,0.4);
            display: flex; justify-content: center; align-items: center;
            font-size: clamp(16px, 5cqw, 40px); font-weight: bold; user-select: none;
            position: absolute; z-index: 10;
            transition: transform 0.2s, top 0.2s, left 0.2s;
        }
        
        .piece.hidden {
            background: radial-gradient(circle, #8b4513 30%, #5c4033 100%);
            color: transparent; border-color: #3e2723;
        }
        .piece.hidden::after { content: "âœ¦"; color: rgba(255,255,255,0.15); font-size: 1.2rem; }
        .piece.red { color: var(--piece-red); }
        .piece.black { color: var(--piece-black); }
        .piece.selected { transform: scale(1.15); z-index: 20; box-shadow: 0 0 0 3px #f1c40f, 0 0 10px #f1c40f; }

        /* Invincible State */
        .piece.invincible {
            border-color: #f1c40f;
            box-shadow: 0 0 10px #f1c40f, 0 0 20px #f39c12, inset 0 0 10px #fff;
            animation: golden-pulse 1.5s infinite alternate;
        }
        .piece.invincible::after {
            content: 'ğŸ›¡ï¸'; position: absolute; top: -5px; right: -5px; font-size: 0.8rem; z-index: 25;
        }
        @keyframes golden-pulse {
            0% { box-shadow: 0 0 10px #f1c40f, 0 0 20px #f39c12; transform: scale(1); }
            100% { box-shadow: 0 0 20px #f1c40f, 0 0 40px #f39c12; transform: scale(1.02); }
        }

        .piece.firefighter {
            border-width: 3px; display: flex; flex-direction: column; justify-content: center; align-items: center; line-height: 1;
        }
        .piece.firefighter.red { background-color: #fff0f0; border-color: #c0392b; color: #c0392b; }
        .piece.firefighter.red::before { content: 'ğŸ”¥'; font-size: 0.7rem; position: absolute; top: 1px; right: 1px; }
        .piece.firefighter.black { background-color: #dcdde1; border-color: #2c3e50; border-style: double; color: #2c3e50; }
        .piece.firefighter.black::before { content: 'ğŸ’§'; font-size: 0.7rem; position: absolute; top: 1px; left: 1px; }
        
        .charge-bar { position: absolute; bottom: 5%; display: flex; gap: 2px; height: 6px; align-items: center; }
        .charge-pip { width: 5px; height: 5px; border-radius: 50%; background: #ccc; border: 1px solid #777; }
        .charge-pip.on { background: #3498db; border-color: #2980b9; box-shadow: 0 0 3px #3498db; }
        .charge-pip.cannon-on { background: #e67e22; border-color: #d35400; box-shadow: 0 0 3px #e67e22; }
        .charge-pip.storm-on { background: #9b59b6; border-color: #8e44ad; box-shadow: 0 0 3px #9b59b6; }
        .charge-pip.gold-on { background: #f1c40f; border-color: #f39c12; box-shadow: 0 0 3px #f1c40f; }
        .charge-pip.elephant-on { background: #2ecc71; border-color: #27ae60; box-shadow: 0 0 3px #2ecc71; }
        .charge-pip.horse-on { background: #00cec9; border-color: #00b894; box-shadow: 0 0 3px #00cec9; }
        .charge-pip.nitro-on { background: #00cec9; border-color: #00b894; box-shadow: 0 0 3px #00cec9; }

        /* --- Animations --- */
        .jet-beam {
            position: absolute; height: 12px; background: linear-gradient(90deg, rgba(52, 152, 219, 0.9), rgba(133, 193, 233, 0.5) 80%, rgba(255,255,255,0));
            box-shadow: 0 0 10px #3498db, 0 0 20px #2980b9; border-radius: 6px; z-index: 999;
            transform-origin: left center; pointer-events: none; opacity: 0; transition: opacity 0.1s;
        }
        .fire-beam {
            position: absolute; height: 14px; background: linear-gradient(90deg, #ff4500, #ff8c00 70%, rgba(255,255,0,0));
            box-shadow: 0 0 10px #ff4500, 0 0 20px #ffa500; border-radius: 7px; z-index: 999;
            transform-origin: left center; pointer-events: none; opacity: 0; transition: opacity 0.1s;
        }
        .nitro-trail {
            position: absolute; height: 100%; width: 100%;
            background: linear-gradient(to right, transparent, rgba(0, 206, 201, 0.8));
            z-index: 5; pointer-events: none; opacity: 0.8;
            transition: opacity 0.3s;
        }
        .storm-beam {
            position: absolute; height: 40px; 
            background: linear-gradient(90deg, rgba(200, 255, 255, 0.2), rgba(0, 255, 255, 0.6) 20%, rgba(255, 255, 255, 0.8) 50%, rgba(0, 255, 255, 0.6) 80%, rgba(200, 255, 255, 0.2));
            box-shadow: 0 0 20px #00ffff, 0 0 40px rgba(138, 43, 226, 0.5);
            z-index: 999; transform-origin: left center; pointer-events: none; opacity: 0; transition: opacity 0.2s;
            mix-blend-mode: hard-light;
        }
        .explosion-effect {
            position: absolute; width: 300%; height: 300%; top: -100%; left: -100%;
            background: radial-gradient(circle, rgba(255,69,0,0.8) 10%, rgba(255,165,0,0.6) 40%, rgba(0,0,0,0) 70%);
            z-index: 998; pointer-events: none; animation: explode 0.6s ease-out forwards; border-radius: 50%;
        }
        .shockwave-effect {
            position: absolute; width: 300%; height: 300%; top: -100%; left: -100%;
            border: 15px solid rgba(46, 204, 113, 0.8); border-radius: 50%; box-sizing: border-box;
            z-index: 998; pointer-events: none; animation: shockwave 0.5s ease-out forwards;
        }
        @keyframes explode { 0% { transform: scale(0); opacity: 0; } 30% { transform: scale(1); opacity: 1; } 100% { transform: scale(1.2); opacity: 0; } }
        @keyframes shockwave { 0% { transform: scale(0); opacity: 1; border-width: 20px; } 100% { transform: scale(1.2); opacity: 0; border-width: 0px; } }
        
        .teleport-orb {
            position: absolute; border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.9) 10%, rgba(155, 89, 182, 0.8) 60%, rgba(142, 68, 173, 0) 70%);
            box-shadow: 0 0 15px rgba(155, 89, 182, 0.8), 0 0 30px rgba(142, 68, 173, 0.4);
            z-index: 998; pointer-events: none; transition: all 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55); mix-blend-mode: screen;
        }
        .resurrect-soul {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center; font-size: 2rem;
            z-index: 1000; pointer-events: none; animation: riseFade 1.2s forwards ease-in-out;
            text-shadow: 0 0 10px #9b59b6, 0 0 20px #8e44ad;
        }
        @keyframes riseFade { 0% { transform: translateY(0) scale(0.5); opacity: 0; } 20% { opacity: 1; transform: translateY(-10px) scale(1.2); } 80% { opacity: 0.8; } 100% { transform: translateY(-60px) scale(1.5); opacity: 0; } }

        .highlight-move::before { content: ''; position: absolute; width: 20%; height: 20%; background: #2ecc71; border-radius: 50%; opacity: 0.8; }
        .highlight-capture { background-color: var(--valid-capture); box-shadow: inset 0 0 10px #c0392b; }
        .highlight-dark-attack { background-color: var(--valid-dark-attack); box-shadow: inset 0 0 10px #d35400; }
        .highlight-skill-target { background-color: rgba(52, 152, 219, 0.6); box-shadow: inset 0 0 15px #3498db; cursor: crosshair; animation: pulse-blue 1s infinite; }
        .highlight-cannon-target { background-color: var(--valid-cannon-skill); box-shadow: inset 0 0 15px #e67e22; cursor: crosshair; animation: pulse-orange 1s infinite; }
        .highlight-storm-target { background-color: var(--valid-storm-skill); box-shadow: inset 0 0 15px #8e44ad; cursor: pointer; animation: pulse-purple 1s infinite; }
        .highlight-nitro-target { background-color: var(--valid-nitro-skill); box-shadow: inset 0 0 15px #00cec9; cursor: pointer; animation: pulse-cyan 1s infinite; }
        @keyframes pulse-blue { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }
        @keyframes pulse-orange { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }
        @keyframes pulse-purple { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }
        @keyframes pulse-cyan { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }
        .fail-shake { animation: shake 0.4s; }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }

        /* --- Controls Area --- */
        /* Placed in flow at the bottom */
        #controls-area {
            flex: 0 0 auto;
            width: 100%;
            background: rgba(30, 30, 30, 0.8);
            backdrop-filter: blur(5px);
            border-top: 1px solid #555;
            padding: 8px;
            padding-bottom: calc(8px + var(--safe-bottom));
            display: flex; flex-wrap: wrap; justify-content: center; gap: 8px;
            z-index: 100;
        }

        .action-btn {
            padding: 10px 15px; font-size: 0.95rem; border: none; border-radius: 10px; cursor: pointer;
            color: white; display: none; box-shadow: 0 3px 0 rgba(0,0,0,0.3);
            align-items: center; justify-content: center; font-weight: bold; flex-grow: 1; max-width: 48%;
        }
        .action-btn:active { transform: translateY(3px); box-shadow: none; }
        
        #btn-skill-jet { background: #3498db; }
        #btn-skill-cannon { background: #d35400; }
        #btn-skill-storm { background: #8e44ad; }
        #btn-skill-gold { background: #f1c40f; color: #333; }
        #btn-skill-elephant { background: #27ae60; }
        #btn-skill-nitro { background: #00cec9; color: #333; }
        
        #btn-skill-jet.disabled, #btn-skill-cannon.disabled, 
        #btn-skill-storm.disabled, #btn-skill-gold.disabled, 
        #btn-skill-elephant.disabled, #btn-skill-nitro.disabled { 
            background: #7f8c8d; opacity: 0.6; pointer-events: none; color: #ccc;
        }
        
        #btn-pawn-swap { background: #9b59b6; }
        #btn-pawn-rez { background: #f1c40f; color: #333; }
        #btn-pawn-equip { background: #27ae60; }
        #btn-cancel { background: #e74c3c; max-width: 30%; }
        #btn-end-capture { background: #e67e22; }
        #btn-reset { background: #95a5a6; max-width: 20%; font-size: 0.9rem; padding: 5px; }

        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 2000;
            display: flex; justify-content: center; align-items: center; padding: 20px; box-sizing: border-box;
        }
        .modal-content {
            background: #fff; color: #333; padding: 20px; border-radius: 15px;
            text-align: center; width: 100%; max-width: 350px; border: 5px solid #f1c40f;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
        }
        .modal-btns { display: flex; gap: 10px; justify-content: center; margin-top: 20px; }
        
        #message-overlay {
            position: fixed; top: 40%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9); color: #f1c40f; padding: 15px 30px; border-radius: 50px;
            font-size: 1.5rem; pointer-events: none; opacity: 0; transition: opacity 0.3s; z-index: 1500;
            white-space: nowrap; border: 2px solid #f1c40f;
        }

        /* --- DESKTOP LAYOUT (Horizontal) --- */
        @media (min-width: 768px) {
            #main-wrapper {
                flex-direction: row; /* Horizontal layout for board and panels */
                align-items: center;
                justify-content: center;
                max-width: 1200px;
                height: 85vh; /* Reserve space for controls at bottom */
            }

            .side-panel {
                width: 120px;
                height: 100%;
                justify-content: flex-start;
                gap: 10px;
            }

            #red-panel { order: 1; }
            
            .board-container { 
                order: 2; 
                flex: 1; 
                height: 100%;
                padding: 0 20px;
            }

            #board {
                height: 95%; /* Make it big but leave margin */
                max-height: 750px;
                width: auto;
            }

            #black-panel { order: 3; }

            .graveyard-box {
                width: 100%; height: auto; flex: 1;
                flex-direction: column; /* Stack pieces vertically */
                flex-wrap: wrap; /* Grid like if too many pieces */
                align-content: center; justify-content: flex-start;
                overflow-y: auto; overflow-x: hidden;
                padding: 10px 0;
            }
            
            .graveyard-piece { margin-bottom: 5px; }

            #controls-area {
                /* Keep controls at bottom in flow, separate from main-wrapper */
                position: relative; 
                width: 100%; 
                height: 15vh;
                min-height: 80px;
                align-items: center;
                background: transparent;
                border-top: none;
            }
            .action-btn { font-size: 1rem; padding: 12px 20px; max-width: 200px; }
        }
    </style>
</head>
<body>

<div id="start-screen" class="screen">
    <h1>æš—æ£‹å°æ±º</h1>
    <button class="menu-btn" onclick="game.startGame('STANDARD')">ç¶“å…¸é€£åƒç‰ˆ</button>
    <button class="menu-btn btn-blue" onclick="game.startGame('SPECIAL')">ç‰¹æ®Šæ¨¡å¼ï¼šå…¨è‹±é›„å¤§äº‚é¬¥</button>
</div>

<div id="game-over-screen" class="screen hidden-screen">
    <h1 id="winner-title">éŠæˆ²çµæŸ</h1>
    <button class="menu-btn btn-green" onclick="game.resetToMenu()">é‡æ–°éŠç©</button>
</div>

<div id="promotion-modal" class="modal-overlay hidden-screen">
    <div class="modal-content">
        <h2 style="margin:0 0 10px 0;">ğŸš’ ç™¼ç¾è£å‚™ï¼</h2>
        <p style="font-size:1.1rem;">æ˜¯å¦è®“é€™åå°å…µç©¿ä¸Šæ¶ˆé˜²è£å‚™ï¼Ÿ</p>
        <div style="background:#eee; padding:10px; border-radius:8px; margin:10px 0; font-size:0.9rem; text-align:left;">
            <strong>èƒ½åŠ›ï¼š</strong>æ¯”å°‡å°ã€æ¯”å£«å¤§<br>
            <strong>æŠ€èƒ½ï¼š</strong>æ°´æŸ±å™´å°„ã€æ›ä½ã€å¾©æ´»<br>
            <hr style="margin:5px 0; border:0; border-top:1px solid #ccc;">
            <strong>ğŸ’¥ ç‚®å…µï¼š</strong>ç«ç„°å™´å°„ (5æ°£)<br>
            <strong>ğŸŒªï¸ å°‡å¸¥ï¼š</strong>é¢¨æš´ä¸€å­—æ–¬ (7æ°£)<br>
            <strong>ğŸ›¡ï¸ å£«ä»•ï¼š</strong>é‡‘å‰›ä¸å£ (6æ°£)<br>
            <strong>ğŸ˜ è±¡ç›¸ï¼š</strong>è±¡é¼»æ©«æƒ (5æ°£)<br>
            <strong>ğŸ é¦¬å‚Œï¼š</strong>å…«æ–¹å¥”é¦³ (1æ°£)<br>
            <strong>ğŸï¸ è»Šä¿¥ï¼š</strong>æ°®æ°£åŠ é€Ÿ (3æ°£)
        </div>
        <div class="modal-btns">
            <button class="action-btn btn-green" style="display:flex; background:#2ecc71;" onclick="game.confirmPromotion(true)">âœ… ç©¿è£å‚™</button>
            <button class="action-btn" style="display:flex; background:#95a5a6;" onclick="game.confirmPromotion(false)">âŒ ä¿æŒåŸç‹€</button>
        </div>
    </div>
</div>

<!-- Flex Wrapper for responsive layout -->
<div id="main-wrapper">
    <div class="side-panel" id="red-panel">
        <div id="status-bar"><div id="turn-display" class="turn-indicator">æº–å‚™é–‹å§‹</div></div>
        <div class="graveyard-box" id="graveyard-red-strip"></div>
    </div>
    
    <div class="board-container">
        <div id="board"></div>
    </div>
    
    <div class="side-panel" id="black-panel">
        <div class="graveyard-box" id="graveyard-black-strip"></div>
    </div>
</div>

<div id="controls-area">
    <button id="btn-skill-jet" class="action-btn" onclick="game.activateSkill('JET')">ğŸŒŠ æ°´æŸ±å™´å°„</button>
    <button id="btn-skill-cannon" class="action-btn" onclick="game.activateSkill('CANNON_FIRE')">ğŸ”¥ ç«ç„°å™´å°„</button>
    <button id="btn-skill-storm" class="action-btn" onclick="game.activateSkill('STORM_SLASH')">ğŸŒªï¸ é¢¨æš´ä¸€å­—æ–¬</button>
    <button id="btn-skill-gold" class="action-btn" onclick="game.activateSkill('GOLDEN_BODY')">ğŸ›¡ï¸ é‡‘å‰›ä¸å£</button>
    <button id="btn-skill-elephant" class="action-btn" onclick="game.activateSkill('ELEPHANT_SWEEP')">ğŸ˜ è±¡é¼»æ©«æƒ</button>
    <button id="btn-skill-nitro" class="action-btn" onclick="game.activateSkill('NITRO')">ğŸï¸ æ°®æ°£åŠ é€Ÿ</button>
    
    <button id="btn-pawn-swap" class="action-btn" onclick="game.pawnAction('SWAP')">ğŸ”„ èˆ‡å¤§å“¥æ›ä½</button>
    <button id="btn-pawn-rez" class="action-btn" onclick="game.pawnAction('RESURRECT')">âš°ï¸ çŠ§ç‰²å¬å–š</button>
    <button id="btn-pawn-equip" class="action-btn" onclick="game.pawnAction('EQUIP')">ğŸ› ï¸ è£å‚™æ¶ˆé˜²æ “</button>
    
    <button id="btn-end-capture" class="action-btn" onclick="game.endTurn()">â¹ åœæ­¢é€£åƒ</button>
    <button id="btn-cancel" class="action-btn" onclick="game.cancelAction()">âŒ å–æ¶ˆ</button>
    <button id="btn-reset" class="action-btn" style="display:flex;" onclick="game.resetToMenu()">âŸ²</button>
</div>

<div id="message-overlay"></div>

<script>
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const Sound = {
        play: (freq, type, dur, vol=0.1) => {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(vol, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + dur);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + dur);
        },
        flip: () => Sound.play(600, 'square', 0.08),
        move: () => Sound.play(150, 'triangle', 0.1),
        capture: () => Sound.play(100, 'sawtooth', 0.2, 0.2),
        error: () => Sound.play(80, 'sawtooth', 0.2),
        fail: () => { Sound.play(150, 'sawtooth', 0.1); setTimeout(()=>Sound.play(100, 'sawtooth', 0.1), 100); },
        skill: () => { [400, 600, 800].forEach((f,i) => setTimeout(()=>Sound.play(f,'sine',0.2), i*100)); },
        metal: () => { Sound.play(200, 'square', 0.05, 0.2); setTimeout(()=>Sound.play(150, 'square', 0.1, 0.2), 50); },
        heavy: () => { Sound.play(100, 'square', 0.3, 0.3); },
        bounce: () => { Sound.play(200, 'triangle', 0.1); setTimeout(()=>Sound.play(300, 'triangle', 0.2), 100); },
        jet: () => {
             if(audioCtx.state === 'suspended') audioCtx.resume();
             const bufferSize = audioCtx.sampleRate * 0.5;
             const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
             const data = buffer.getChannelData(0);
             for(let i=0; i<bufferSize; i++) data[i] = Math.random() * 2 - 1;
             const noise = audioCtx.createBufferSource(); noise.buffer = buffer;
             const gain = audioCtx.createGain(); gain.gain.setValueAtTime(0.3, audioCtx.currentTime); 
             gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime+0.5);
             noise.connect(gain); gain.connect(audioCtx.destination); noise.start();
        },
        storm: () => {
             if(audioCtx.state === 'suspended') audioCtx.resume();
             const bufferSize = audioCtx.sampleRate * 1.5;
             const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
             const data = buffer.getChannelData(0);
             for(let i=0; i<bufferSize; i++) data[i] = (Math.random() * 2 - 1);
             const noise = audioCtx.createBufferSource(); noise.buffer = buffer;
             const gain = audioCtx.createGain();
             const filter = audioCtx.createBiquadFilter();
             filter.type = "bandpass"; filter.frequency.setValueAtTime(400, audioCtx.currentTime);
             filter.frequency.linearRampToValueAtTime(1000, audioCtx.currentTime + 1.5);
             gain.gain.setValueAtTime(0.0, audioCtx.currentTime);
             gain.gain.linearRampToValueAtTime(0.5, audioCtx.currentTime + 0.2); 
             gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime+1.5);
             noise.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination); 
             noise.start();
        },
        explosion: () => {
             if(audioCtx.state === 'suspended') audioCtx.resume();
             const bufferSize = audioCtx.sampleRate * 0.8;
             const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
             const data = buffer.getChannelData(0);
             for(let i=0; i<bufferSize; i++) data[i] = (Math.random() * 2 - 1) * (1 - i/bufferSize);
             const noise = audioCtx.createBufferSource(); noise.buffer = buffer;
             const gain = audioCtx.createGain(); 
             const filter = audioCtx.createBiquadFilter();
             filter.type = "lowpass"; filter.frequency.value = 800;
             gain.gain.setValueAtTime(1.0, audioCtx.currentTime); 
             gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime+0.8);
             noise.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination); 
             noise.start();
        },
        teleport: () => {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(200, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.5);
            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + 0.5);
        },
        win: () => { [300, 400, 500, 600].forEach((f,i) => setTimeout(()=>Sound.play(f,'sine',0.3), i*150)); }
    };

    const PIECES = {
        RED: [
            {id:'r7',n:'å¸¥',r:7,c:1},{id:'r6',n:'ä»•',r:6,c:2},{id:'r5',n:'ç›¸',r:5,c:2},
            {id:'r4',n:'ä¿¥',r:4,c:2},{id:'r3',n:'å‚Œ',r:3,c:2},{id:'r2',n:'ç‚®',r:2,c:2},
            {id:'r1',n:'å…µ',r:1,c:5}
        ],
        BLACK: [
            {id:'b7',n:'å°‡',r:7,c:1},{id:'b6',n:'å£«',r:6,c:2},{id:'b5',n:'è±¡',r:5,c:2},
            {id:'b4',n:'è»Š',r:4,c:2},{id:'b3',n:'é¦¬',r:3,c:2},{id:'b2',n:'åŒ…',r:2,c:2},
            {id:'b1',n:'å’',r:1,c:5}
        ]
    };

    class DarkChess {
        constructor() {
            this.board = [];
            this.turn = null; 
            this.myColor = null; 
            this.selectedIdx = -1;
            this.mode = 'STANDARD';
            this.gameOver = false;
            this.isChainCapturing = false;
            this.chainIdx = -1;
            this.pendingPromoIdx = -1;
            this.pendingPromoCtx = false;
            this.isFirstMove = true;
            this.skillMode = null;
            this.animating = false;
        }

        startGame(mode) {
            this.mode = mode;
            document.getElementById('start-screen').classList.add('hidden-screen');
            this.init();
        }

        init() {
            let pool = [];
            // Init pieces. invT = invincibleTurns
            PIECES.RED.forEach(p => { for(let i=0; i<p.c; i++) pool.push({...p, color:'red', revealed:false, isFF:false, charge:0, invincibleTurns:0}); });
            PIECES.BLACK.forEach(p => { for(let i=0; i<p.c; i++) pool.push({...p, color:'black', revealed:false, isFF:false, charge:0, invincibleTurns:0}); });
            
            for(let i=pool.length-1; i>0; i--){
                const j = Math.floor(Math.random()*(i+1));
                [pool[i], pool[j]] = [pool[j], pool[i]];
            }

            this.board = pool;
            this.turn = null;
            this.myColor = null;
            this.selectedIdx = -1;
            this.isChainCapturing = false;
            this.chainIdx = -1;
            this.isFirstMove = true;
            this.gameOver = false;
            this.skillMode = null;
            this.animating = false;
            
            document.getElementById('graveyard-red-strip').innerHTML = '';
            document.getElementById('graveyard-black-strip').innerHTML = '';
            
            this.render();
            this.updateUI("è«‹ç¿»ç‰Œæ±ºå®šå…ˆå¾Œæ‰‹");
            this.resetControls();
        }

        resetToMenu() {
            this.gameOver = false;
            document.getElementById('game-over-screen').classList.add('hidden-screen');
            document.getElementById('promotion-modal').classList.add('hidden-screen');
            document.getElementById('message-overlay').style.opacity = 0;
            document.getElementById('start-screen').classList.remove('hidden-screen');
            document.getElementById('board').innerHTML = '';
            document.getElementById('graveyard-red-strip').innerHTML = '';
            document.getElementById('graveyard-black-strip').innerHTML = '';
        }

        render() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            
            const updateFontSize = () => {
                const cell = boardEl.firstElementChild;
                if(cell) {
                    const size = Math.min(cell.clientWidth, cell.clientHeight) * 0.55;
                    const pieces = document.querySelectorAll('.piece');
                    pieces.forEach(p => p.style.fontSize = size + 'px');
                }
            };

            this.board.forEach((p, idx) => {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.id = `cell-${idx}`;
                cell.onclick = () => this.handleCellClick(idx);
                
                if(p) {
                    let classes = `piece ${p.color} ${p.revealed ? '':'hidden'} ${p.isFF ? 'firefighter':''}`;
                    if (p.invincibleTurns > 0) classes += ' invincible';
                    
                    const el = document.createElement('div');
                    el.className = classes;
                    el.id = `piece-${idx}`;
                    
                    if(p.revealed) {
                        if (p.isFF) {
                            el.innerText = p.color === 'red' ? 'ğŸ‘¨â€ğŸš’' : 'ğŸ¥·'; 
                        } else {
                            el.innerText = p.n;
                        }

                        let maxCharge = 0;
                        if (p.isFF) maxCharge = 3;
                        else if (p.r === 2 && this.mode === 'SPECIAL') maxCharge = 5;
                        else if (p.r === 7 && this.mode === 'SPECIAL') maxCharge = 7;
                        else if (p.r === 6 && this.mode === 'SPECIAL') maxCharge = 6;
                        else if (p.r === 5 && this.mode === 'SPECIAL') maxCharge = 5;
                        else if (p.r === 4 && this.mode === 'SPECIAL') maxCharge = 3; // Rook
                        else if (p.r === 3 && this.mode === 'SPECIAL') maxCharge = 1;

                        if(maxCharge > 0) {
                            const bar = document.createElement('div');
                            bar.className = 'charge-bar';
                            for(let i=0; i<maxCharge; i++) {
                                const pip = document.createElement('div');
                                let onClass = 'on';
                                if (p.r === 2) onClass = 'cannon-on';
                                if (p.r === 7) onClass = 'storm-on';
                                if (p.r === 6) onClass = 'gold-on';
                                if (p.r === 5) onClass = 'elephant-on';
                                if (p.r === 3) onClass = 'horse-on';
                                if (p.r === 4) onClass = 'nitro-on';
                                pip.className = `charge-pip ${i < p.charge ? onClass:''}`;
                                bar.appendChild(pip);
                            }
                            el.appendChild(bar);
                        }
                    }
                    if(this.selectedIdx === idx) el.classList.add('selected');
                    cell.appendChild(el);
                }
                boardEl.appendChild(cell);
            });
            requestAnimationFrame(updateFontSize);
        }

        handleCellClick(idx) {
            if(this.gameOver || this.animating) return;
            const p = this.board[idx];

            if(this.skillMode === 'JET') { this.executeJetSkill(idx); return; }
            if(this.skillMode === 'CANNON_FIRE') { this.executeCannonSkill(idx); return; }
            if(this.skillMode === 'STORM_SLASH') { this.executeStormSkill(idx); return; }
            if(this.skillMode === 'ELEPHANT_SWEEP') { this.executeElephantSkill(); return; }
            if(this.skillMode === 'NITRO') { this.executeNitroSkill(idx); return; }

            if(this.isChainCapturing) {
                if(idx === this.chainIdx) return;
                if(p) {
                    const res = this.checkAttack(this.chainIdx, idx);
                    if(res.valid || res.isDark) {
                        this.executeAttack(this.chainIdx, idx, res.isDark);
                    } else {
                        Sound.error();
                        this.showMsg("ç„¡æ³•æ”»æ“Š");
                    }
                } else {
                    Sound.error();
                    this.showMsg("ä¸å¯èµ°ç©ºåœ°");
                }
                return;
            }

            // A. First Flip
            if(this.turn === null) {
                if(p && !p.revealed) this.performFirstFlip(idx);
                return;
            }

            // B. Selection
            if(p && p.revealed && p.color === this.turn) {
                this.selectPiece(idx);
                return;
            }

            // C. Action
            if(this.selectedIdx !== -1) {
                if(idx === this.selectedIdx) { this.cancelAction(); return; }
                
                if(!p) {
                    if(this.isAdjacent(this.selectedIdx, idx)) {
                        this.executeMove(this.selectedIdx, idx);
                    } else {
                        this.cancelAction();
                        Sound.error();
                    }
                    return;
                }

                const res = this.checkAttack(this.selectedIdx, idx);
                if(res.reachable) {
                    if(res.valid || res.isDark) {
                        this.executeAttack(this.selectedIdx, idx, res.isDark);
                    } else {
                        Sound.error();
                        this.shakePiece(this.selectedIdx);
                        if(p.invincibleTurns > 0) {
                            Sound.metal();
                            this.showMsg("é‡‘å‰›ä¸å£ï¼ç„¡æ³•æ”»æ“Š");
                        } else {
                            this.showMsg("æ‰“ä¸éï¼");
                        }
                    }
                } else {
                    this.cancelAction();
                }
                return;
            }

            // D. Normal Flip
            if(p && !p.revealed) {
                this.performNormalFlip(idx);
            }
        }

        performFirstFlip(idx) {
            const p = this.board[idx];
            p.revealed = true;
            this.myColor = p.color;
            Sound.flip();
            this.render();

            if(this.mode === 'SPECIAL' && p.r === 1 && !this.hasFirefighterOnBoard(p.color)) {
                this.triggerPromotion(idx, true); 
            } else {
                this.turn = (p.color === 'red') ? 'black' : 'red';
                this.isFirstMove = true; 
                this.updateUI();
            }
        }

        performNormalFlip(idx) {
            const p = this.board[idx];
            p.revealed = true;
            Sound.flip();
            this.render();

            if(this.mode === 'SPECIAL' && p.r === 1 && p.color === this.turn && !this.hasFirefighterOnBoard(p.color)) {
                this.triggerPromotion(idx, false);
            } else {
                this.isFirstMove = false;
                this.endTurn();
            }
        }

        triggerPromotion(idx, isFirstMoveCtx) {
            this.pendingPromoIdx = idx;
            this.pendingPromoCtx = isFirstMoveCtx;
            document.getElementById('promotion-modal').classList.remove('hidden-screen');
        }

        confirmPromotion(yes) {
            document.getElementById('promotion-modal').classList.add('hidden-screen');
            if (this.pendingPromoIdx === -1 || !this.board[this.pendingPromoIdx]) {
                if (this.turn === null) this.init(); 
                return;
            }
            const p = this.board[this.pendingPromoIdx];
            if(yes) {
                p.isFF = true; p.r = 6.5; p.n = 'æ¶ˆé˜²æ “';
                Sound.skill();
                this.showMsg("æ¶ˆé˜²æ “ç™»å ´ï¼");
            }
            if (this.pendingPromoCtx) {
                this.turn = (p.color === 'red') ? 'black' : 'red';
                this.isFirstMove = true;
                this.updateUI();
                this.render();
            } else {
                this.isFirstMove = false;
                this.endTurn();
            }
            this.pendingPromoIdx = -1;
        }

        hasFirefighterOnBoard(color) { return this.board.some(p => p && p.color === color && p.isFF); }
        hasFirefighterInGraveyard(color) {
            const graveId = color === 'red' ? 'graveyard-red-strip' : 'graveyard-black-strip';
            return document.getElementById(graveId).innerHTML.includes('ff-dead');
        }

        selectPiece(idx) {
            this.cancelAction();
            this.selectedIdx = idx;
            const p = this.board[idx];
            Sound.flip();
            this.render();
            this.highlightTargets(idx);

            if(this.mode === 'SPECIAL') {
                const jetBtn = document.getElementById('btn-skill-jet');
                const cannonBtn = document.getElementById('btn-skill-cannon');
                const stormBtn = document.getElementById('btn-skill-storm');
                const goldBtn = document.getElementById('btn-skill-gold');
                const elephantBtn = document.getElementById('btn-skill-elephant');
                const nitroBtn = document.getElementById('btn-skill-nitro');
                
                const swapBtn = document.getElementById('btn-pawn-swap');
                const rezBtn = document.getElementById('btn-pawn-rez');
                const equipBtn = document.getElementById('btn-pawn-equip');
                const cancelBtn = document.getElementById('btn-cancel');

                if(p.isFF) {
                    jetBtn.style.display = 'flex'; 
                    if (p.charge < 3) {
                        jetBtn.classList.add('disabled');
                        jetBtn.innerText = `é›†æ°£ä¸­ (${p.charge}/3)`;
                    } else {
                        jetBtn.classList.remove('disabled');
                        jetBtn.innerText = `ğŸŒŠ æ°´æŸ±å™´å°„ (READY)`;
                    }
                    cancelBtn.style.display = 'flex';
                }
                else if (p.r === 2) { 
                    cannonBtn.style.display = 'flex';
                    if (p.charge < 5) {
                        cannonBtn.classList.add('disabled');
                        cannonBtn.innerText = `é›†æ°£ä¸­ (${p.charge}/5)`;
                    } else {
                        cannonBtn.classList.remove('disabled');
                        cannonBtn.innerText = `ğŸ”¥ ç«ç„°å™´å°„ (READY)`;
                    }
                    cancelBtn.style.display = 'flex';
                }
                else if (p.r === 7) { 
                    stormBtn.style.display = 'flex';
                    if (p.charge < 7) {
                        stormBtn.classList.add('disabled');
                        stormBtn.innerText = `é›†æ°£ä¸­ (${p.charge}/7)`;
                    } else {
                        stormBtn.classList.remove('disabled');
                        stormBtn.innerText = `ğŸŒªï¸ é¢¨æš´ä¸€å­—æ–¬ (READY)`;
                    }
                    cancelBtn.style.display = 'flex';
                }
                else if (p.r === 6) { 
                    goldBtn.style.display = 'flex';
                    if (p.charge < 6) {
                        goldBtn.classList.add('disabled');
                        goldBtn.innerText = `é›†æ°£ä¸­ (${p.charge}/6)`;
                    } else {
                        goldBtn.classList.remove('disabled');
                        goldBtn.innerText = `ğŸ›¡ï¸ é‡‘å‰›ä¸å£ (READY)`;
                    }
                    cancelBtn.style.display = 'flex';
                }
                else if (p.r === 5) { 
                    elephantBtn.style.display = 'flex';
                    if (p.charge < 5) {
                        elephantBtn.classList.add('disabled');
                        elephantBtn.innerText = `é›†æ°£ä¸­ (${p.charge}/5)`;
                    } else {
                        elephantBtn.classList.remove('disabled');
                        elephantBtn.innerText = `ğŸ˜ è±¡é¼»æ©«æƒ (READY)`;
                    }
                    cancelBtn.style.display = 'flex';
                }
                else if (p.r === 4) { // Rook
                    nitroBtn.style.display = 'flex';
                    if (p.charge < 3) {
                        nitroBtn.classList.add('disabled');
                        nitroBtn.innerText = `é›†æ°£ä¸­ (${p.charge}/3)`;
                    } else {
                        nitroBtn.classList.remove('disabled');
                        nitroBtn.innerText = `ğŸï¸ æ°®æ°£åŠ é€Ÿ (READY)`;
                    }
                    cancelBtn.style.display = 'flex';
                }
                else if (p.r === 1) { 
                    const hasFF = this.hasFirefighterOnBoard(p.color);
                    const hasDeadFF = this.hasFirefighterInGraveyard(p.color);
                    if (!hasFF && !hasDeadFF) equipBtn.style.display = 'flex';
                    if(hasFF) swapBtn.style.display = 'flex';
                    if(hasDeadFF) rezBtn.style.display = 'flex';
                    cancelBtn.style.display = 'flex';
                }
            }
        }

        activateSkill(type) {
            if (type === 'JET') {
                this.skillMode = 'JET';
                this.highlightJetTargets();
                document.getElementById('btn-skill-jet').style.display = 'none';
            }
            else if (type === 'CANNON_FIRE') {
                this.skillMode = 'CANNON_FIRE';
                this.highlightCannonTargets();
                document.getElementById('btn-skill-cannon').style.display = 'none';
            }
            else if (type === 'STORM_SLASH') {
                this.skillMode = 'STORM_SLASH';
                this.highlightStormTargets();
                document.getElementById('btn-skill-storm').style.display = 'none';
            }
            else if (type === 'GOLDEN_BODY') {
                this.executeGoldenBody();
            }
            else if (type === 'ELEPHANT_SWEEP') {
                this.executeElephantSkill();
            }
            else if (type === 'NITRO') {
                this.skillMode = 'NITRO';
                this.highlightNitroTargets();
                document.getElementById('btn-skill-nitro').style.display = 'none';
            }
        }

        pawnAction(type) {
            const pawnIdx = this.selectedIdx;
            const pawn = this.board[pawnIdx];
            
            if (type === 'SWAP') {
                const ffIdx = this.board.findIndex(p => p && p.color === pawn.color && p.isFF);
                if (ffIdx !== -1) {
                    Sound.teleport();
                    this.showSwapAnimation(pawnIdx, ffIdx, () => {
                        this.board[pawnIdx] = this.board[ffIdx];
                        this.board[ffIdx] = pawn;
                        this.render();
                        this.endTurn();
                    });
                }
            } 
            else if (type === 'RESURRECT') {
                Sound.skill();
                this.showResurrectAnimation(pawnIdx, () => {
                    this.addToGraveyard(pawn);
                    const graveId = pawn.color === 'red' ? 'graveyard-red-strip' : 'graveyard-black-strip';
                    const ffEl = document.getElementById(graveId).querySelector('.ff-dead');
                    if(ffEl) ffEl.remove();

                    const newFF = { id: 'ff-'+Date.now(), color: pawn.color, revealed: true, isFF: true, r: 6.5, n: 'æ¶ˆé˜²æ “', charge: 0 };
                    this.board[pawnIdx] = newFF;
                    this.render();
                    this.endTurn();
                });
            }
            else if (type === 'EQUIP') {
                pawn.isFF = true; pawn.r = 6.5; pawn.n = 'æ¶ˆé˜²æ “';
                Sound.skill();
                this.showMsg("è£å‚™å®Œæˆï¼");
                this.render();
                this.endTurn();
            }
        }

        // --- Targeting Logic ---

        highlightJetTargets() {
            const cells = document.getElementById('board').children;
            const origin = this.selectedIdx;
            const ox=origin%4, oy=Math.floor(origin/4);
            const dirs = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
            this.showMsg("é¸æ“‡å°„æ“Šç›®æ¨™ (å°‡å¸¥å…ç–«)");
            dirs.forEach(d => {
                let cx=ox+d[0], cy=oy+d[1];
                while(cx>=0 && cx<4 && cy>=0 && cy<8) {
                    const idx = cy*4+cx;
                    const p = this.board[idx];
                    if(p) {
                        if(p.revealed && p.color !== this.turn && p.r !== 7) {
                            cells[idx].classList.add('highlight-skill-target');
                        }
                        break; 
                    }
                    cx+=d[0]; cy+=d[1];
                }
            });
        }

        highlightCannonTargets() {
            const cells = document.getElementById('board').children;
            const origin = this.selectedIdx;
            this.showMsg("é¸æ“‡è½Ÿç‚¸ä¸­å¿ƒ (éœ€3x3å…§æœ‰3å­)");
            for(let i=0; i<32; i++) {
                if(i === origin) continue;
                const res = this.checkAttack(origin, i);
                if (res.reachable && (res.valid || res.isDark)) {
                    cells[i].classList.add('highlight-cannon-target');
                }
            }
        }

        highlightStormTargets() {
            const cells = document.getElementById('board').children;
            const origin = this.selectedIdx;
            const ox=origin%4, oy=Math.floor(origin/4);
            const dirs = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
            this.showMsg("é¸æ“‡æ–¹å‘æ–½æ”¾é¢¨æš´ (æ•µæˆ‘ä¸åˆ†)");

            dirs.forEach(d => {
                let cx=ox+d[0], cy=oy+d[1];
                while(cx>=0 && cx<4 && cy>=0 && cy<8) {
                    const idx = cy*4+cx;
                    const p = this.board[idx];
                    if(p) {
                        if (!p.revealed || p.color !== this.turn) {
                            cells[idx].classList.add('highlight-storm-target');
                        }
                    }
                    cx+=d[0]; cy+=d[1];
                }
            });
        }

        highlightNitroTargets() {
            const cells = document.getElementById('board').children;
            const origin = this.selectedIdx;
            const ox=origin%4, oy=Math.floor(origin/4);
            const dirs = [[0,1],[0,-1],[1,0],[-1,0]]; // Orthogonal only
            this.showMsg("é¸æ“‡è¡åˆºæ–¹å‘ (éœ€æœ‰æ£‹å­)");

            dirs.forEach(d => {
                let cx=ox+d[0], cy=oy+d[1];
                while(cx>=0 && cx<4 && cy>=0 && cy<8) {
                    const idx = cy*4+cx;
                    const p = this.board[idx];
                    if(p) {
                        // Found first piece in this direction
                        cells[idx].classList.add('highlight-nitro-target');
                        break; 
                    }
                    cx+=d[0]; cy+=d[1];
                }
            });
        }

        // --- Animations ---

        createOrb(cell) {
            const r = cell.getBoundingClientRect();
            const boardR = document.getElementById('board').getBoundingClientRect();
            const orbSize = r.width * 0.8;
            const orb = document.createElement('div');
            orb.className = 'teleport-orb';
            orb.style.width = orbSize + 'px';
            orb.style.height = orbSize + 'px';
            const left = (r.left - boardR.left) + (r.width - orbSize) / 2;
            const top = (r.top - boardR.top) + (r.height - orbSize) / 2;
            orb.style.left = left + 'px'; orb.style.top = top + 'px';
            return orb;
        }

        showSwapAnimation(idx1, idx2, callback) {
            this.animating = true;
            const board = document.getElementById('board');
            const orb1 = this.createOrb(document.getElementById('cell-' + idx1));
            const orb2 = this.createOrb(document.getElementById('cell-' + idx2));
            board.appendChild(orb1); board.appendChild(orb2);
            void orb1.offsetWidth; 

            const r1 = orb1.style.left; const t1 = orb1.style.top;
            const r2 = orb2.style.left; const t2 = orb2.style.top;

            orb1.style.left = r2; orb1.style.top = t2;
            orb2.style.left = r1; orb2.style.top = t1;

            setTimeout(() => { orb1.remove(); orb2.remove(); this.animating = false; if (callback) callback(); }, 500);
        }

        showJetAnimation(fromIdx, toIdx, color='blue') {
            const board = document.getElementById('board');
            const cell1 = document.getElementById('cell-' + fromIdx);
            const cell2 = document.getElementById('cell-' + toIdx);
            if (!cell1 || !cell2) return;

            const r1 = cell1.getBoundingClientRect();
            const r2 = cell2.getBoundingClientRect();
            const boardR = board.getBoundingClientRect();

            const x1 = r1.left + r1.width/2 - boardR.left;
            const y1 = r1.top + r1.height/2 - boardR.top;
            const x2 = r2.left + r2.width/2 - boardR.left;
            const y2 = r2.top + r2.height/2 - boardR.top;
            const length = Math.hypot(x2-x1, y2-y1);
            const angle = Math.atan2(y2-y1, x2-x1) * 180 / Math.PI;

            const beam = document.createElement('div');
            beam.className = color === 'blue' ? 'jet-beam' : 'fire-beam';
            beam.style.width = length + 'px';
            beam.style.left = x1 + 'px';
            beam.style.top = y1 + 'px';
            beam.style.transform = `translateY(-50%) rotate(${angle}deg)`;

            board.appendChild(beam);
            requestAnimationFrame(() => {
                beam.style.opacity = 1;
                setTimeout(() => { beam.style.opacity = 0; setTimeout(() => { if(beam.parentNode) beam.remove(); }, 200); }, 300);
            });
        }

        showStormAnimation(fromIdx, targetIdx, callback) {
            this.animating = true;
            const board = document.getElementById('board');
            const cell1 = document.getElementById('cell-' + fromIdx);
            const cell2 = document.getElementById('cell-' + targetIdx);
            
            const r1 = cell1.getBoundingClientRect();
            const r2 = cell2.getBoundingClientRect();
            const boardR = board.getBoundingClientRect();

            const x1 = r1.left + r1.width/2 - boardR.left;
            const y1 = r1.top + r1.height/2 - boardR.top;
            
            const dx = (r2.left + r2.width/2) - (r1.left + r1.width/2);
            const dy = (r2.top + r2.height/2) - (r1.top + r1.height/2);
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;
            const length = Math.hypot(boardR.width, boardR.height) * 1.5;

            const beam = document.createElement('div');
            beam.className = 'storm-beam';
            beam.style.width = length + 'px';
            beam.style.left = x1 + 'px';
            beam.style.top = y1 + 'px';
            beam.style.transform = `translateY(-50%) rotate(${angle}deg)`;

            board.appendChild(beam);
            Sound.storm();

            requestAnimationFrame(() => {
                beam.style.opacity = 1;
                setTimeout(() => { 
                    beam.style.opacity = 0; 
                    setTimeout(() => { 
                        if(beam.parentNode) beam.remove();
                        this.animating = false;
                        if(callback) callback();
                    }, 200); 
                }, 500);
            });
        }
        
        showResurrectAnimation(idx, callback) {
            this.animating = true;
            const cell = document.getElementById('cell-' + idx);
            if (!cell) { this.animating = false; if(callback) callback(); return; }
            const soul = document.createElement('div');
            soul.className = 'resurrect-soul'; soul.innerText = 'ğŸ‘»';
            cell.appendChild(soul);
            setTimeout(() => { if(soul.parentNode) soul.remove(); this.animating = false; if(callback) callback(); }, 1200);
        }

        showExplosionAnimation(centerIdx, callback) {
            this.animating = true;
            const board = document.getElementById('board');
            const cell = document.getElementById('cell-' + centerIdx);
            const r = cell.getBoundingClientRect();
            const boardR = board.getBoundingClientRect();
            
            const size = r.width * 3; 
            const exp = document.createElement('div');
            exp.className = 'explosion-effect';
            exp.style.width = size + 'px'; exp.style.height = size + 'px';
            exp.style.left = (r.left - boardR.left + r.width/2 - size/2) + 'px';
            exp.style.top = (r.top - boardR.top + r.height/2 - size/2) + 'px';
            
            board.appendChild(exp);
            Sound.explosion();
            
            setTimeout(() => { exp.remove(); this.animating = false; if(callback) callback(); }, 700);
        }

        showShockwaveAnimation(centerIdx, callback) {
            this.animating = true;
            const board = document.getElementById('board');
            const cell = document.getElementById('cell-' + centerIdx);
            const r = cell.getBoundingClientRect();
            const boardR = board.getBoundingClientRect();
            
            const size = r.width * 3;
            const wave = document.createElement('div');
            wave.className = 'shockwave-effect';
            wave.style.width = size + 'px'; wave.style.height = size + 'px';
            wave.style.left = (r.left - boardR.left + r.width/2 - size/2) + 'px';
            wave.style.top = (r.top - boardR.top + r.height/2 - size/2) + 'px';
            
            board.appendChild(wave);
            Sound.heavy();
            
            setTimeout(() => { wave.remove(); this.animating = false; if(callback) callback(); }, 500);
        }

        showNitroAnimation(fromIdx, dirIdx) {
            const board = document.getElementById('board');
            const cell1 = document.getElementById('cell-' + fromIdx);
            const cell2 = document.getElementById('cell-' + dirIdx); 
            if(!cell1 || !cell2) return;

            const r1 = cell1.getBoundingClientRect();
            const r2 = cell2.getBoundingClientRect();
            const boardR = board.getBoundingClientRect();
            
            const x1 = r1.left + r1.width/2 - boardR.left;
            const y1 = r1.top + r1.height/2 - boardR.top;
            const dx = (r2.left + r2.width/2) - (r1.left + r1.width/2);
            const dy = (r2.top + r2.height/2) - (r1.top + r1.height/2);
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;

            const beam = document.createElement('div');
            beam.className = 'jet-beam';
            beam.style.background = 'linear-gradient(90deg, rgba(0, 206, 201, 0.9), rgba(255,255,255,0))';
            beam.style.boxShadow = '0 0 15px #00cec9';
            beam.style.width = '1000px'; 
            beam.style.left = x1 + 'px';
            beam.style.top = y1 + 'px';
            beam.style.transform = `translateY(-50%) rotate(${angle}deg)`;
            
            board.appendChild(beam);
            requestAnimationFrame(() => {
                beam.style.opacity = 1;
                setTimeout(() => { beam.style.opacity = 0; setTimeout(() => beam.remove(), 200); }, 300);
            });
        }

        showBounceAnimation(fromIdx) {
            this.shakePiece(fromIdx);
            Sound.bounce();
        }

        // --- Executions ---

        executeGoldenBody() {
            const p = this.board[this.selectedIdx];
            p.invincibleTurns = 4; // 2 Rounds = 4 half-turns
            p.charge = 0;
            Sound.metal();
            this.showMsg("é‡‘å‰›ä¸å£ï¼å•Ÿå‹•ï¼");
            this.render();
            this.endTurn();
        }

        executeElephantSkill() {
            const originIdx = this.selectedIdx;
            const cx = originIdx % 4;
            const cy = Math.floor(originIdx / 4);
            const affectedIndices = [];
            let validTargets = 0;

            for(let dy=-1; dy<=1; dy++) {
                for(let dx=-1; dx<=1; dx++) {
                    if (dx===0 && dy===0) continue;
                    const nx=cx+dx, ny=cy+dy;
                    if(nx>=0 && nx<4 && ny>=0 && ny<8) {
                        const idx = ny*4+nx;
                        const p = this.board[idx];
                        if (p) {
                            affectedIndices.push(idx);
                            if (!p.revealed || p.color !== this.turn) {
                                validTargets++;
                            }
                        }
                    }
                }
            }

            if (validTargets === 0) {
                Sound.fail();
                this.showMsg("æ²’æœ‰æ•µæ–¹ï¼");
                return;
            }

            this.showShockwaveAnimation(originIdx, () => {
                const attacker = this.board[originIdx];
                affectedIndices.forEach(idx => {
                    const p = this.board[idx];
                    if(!p) return;
                    
                    let destroyed = false;
                    if(p.revealed) { destroyed = true; } // Destroy all revealed (including ally)
                    else { 
                        p.revealed = true; // Reveal hidden
                        if(p.color !== attacker.color) destroyed = true; // Destroy enemy
                    }
                    
                    if(p.invincibleTurns > 0) destroyed = false; // Immunity

                    if(destroyed) {
                        this.addToGraveyard(p);
                        this.board[idx] = null;
                    }
                });
                attacker.charge = 0;
                this.render();
                this.endTurn();
            });
        }

        executeNitroSkill(targetIdx) {
            const cells = document.getElementById('board').children;
            if(!cells[targetIdx].classList.contains('highlight-nitro-target')) {
                Sound.error(); return;
            }

            // Direction Logic
            const originIdx = this.selectedIdx;
            const cx = originIdx % 4; const cy = Math.floor(originIdx / 4);
            const tx = targetIdx % 4; const ty = Math.floor(targetIdx / 4);
            let dx = tx - cx; let dy = ty - cy;
            if(dx!==0) dx /= Math.abs(dx);
            if(dy!==0) dy /= Math.abs(dy);

            // Collect pieces in path starting from targetIdx
            const piecesToPush = [];
            let currX = tx, currY = ty;
            while(currX >= 0 && currX < 4 && currY >= 0 && currY < 8) {
                const idx = currY * 4 + currX;
                if(this.board[idx]) piecesToPush.push(this.board[idx]);
                currX += dx; currY += dy;
            }

            // Corrected Logic: Calculate available slots FROM target index
            let availableSlots = 0;
            let checkX = tx, checkY = ty;
            while(checkX >= 0 && checkX < 4 && checkY >= 0 && checkY < 8) {
                availableSlots++; 
                checkX += dx; checkY += dy;
            }

            const rook = this.board[originIdx];
            // We need space for Rook + all pieces to push
            // Example: [Rook] -> [P1][P2][Empty] (Edge)
            // Target is P1. Available from P1 is 3 slots.
            // Pieces = P1, P2 (2 pieces). 
            // Need 1 (Rook) + 2 (Pieces) = 3 slots. 3 <= 3 OK.
            const neededSpace = piecesToPush.length + 1; 

            // Case: Bounce (Not enough space)
            if (neededSpace > availableSlots) {
                // Bounce to opposite end
                let bounceX = cx, bounceY = cy;
                let bestX = cx, bestY = cy;
                // Reverse direction
                const rdx = -dx, rdy = -dy;
                
                while(true) {
                    const nx = bounceX + rdx;
                    const ny = bounceY + rdy;
                    if(nx < 0 || nx >= 4 || ny < 0 || ny >= 8) break;
                    if(this.board[ny*4+nx]) break; // Hit a piece behind
                    bounceX = nx; bounceY = ny;
                    bestX = nx; bestY = ny;
                }

                this.showBounceAnimation(originIdx);
                const destIdx = bestY * 4 + bestX;
                
                if (destIdx !== originIdx) {
                    this.board[destIdx] = rook;
                    this.board[originIdx] = null;
                }
                
                this.showMsg("æ’ç‰†åå½ˆï¼(ä¸è€—æ°£)");
                this.render();
                this.endTurn(); // Don't reset charge
            } 
            else {
                // Case: Success Push
                Sound.jet();
                this.showNitroAnimation(originIdx, targetIdx);

                // Safe Move: First, gather data, then clear board, then place.
                // Prevents overwriting issues.
                
                // 1. Remove Rook from origin
                this.board[originIdx] = null;

                // 2. Remove all pushed pieces from board temporarily
                // Note: We already have them in `piecesToPush` array
                let clearX = tx, clearY = ty;
                while(clearX >= 0 && clearX < 4 && clearY >= 0 && clearY < 8) {
                    const idx = clearY * 4 + clearX;
                    this.board[idx] = null; 
                    clearX += dx; clearY += dy;
                }

                // 3. Determine Edge coordinates
                let edgeX = cx, edgeY = cy;
                while(true) {
                    const nx = edgeX + dx, ny = edgeY + dy;
                    if(nx < 0 || nx >= 4 || ny < 0 || ny >= 8) break;
                    edgeX = nx; edgeY = ny;
                }

                // 4. Place Pieces from Edge Backwards
                let placeX = edgeX, placeY = edgeY;
                
                // Reverse iterate piecesToPush (Farthest piece goes to Edge)
                // piecesToPush is [Near...Far] relative to Rook.
                // So piecesToPush[last] is Farthest. It goes to Edge.
                for(let i=piecesToPush.length-1; i>=0; i--) {
                    const p = piecesToPush[i];
                    
                    // Reveal & Destroy Logic
                    let destroyed = false;
                    if(!p.revealed) {
                        p.revealed = true;
                        // Destroy if enemy Rank < 4 (Car)
                        if(p.color !== rook.color && p.r < 4) {
                            destroyed = true;
                        }
                    }
                    
                    if(p.invincibleTurns > 0) destroyed = false;

                    if(destroyed) {
                        this.addToGraveyard(p);
                    } else {
                        const idx = placeY * 4 + placeX;
                        this.board[idx] = p;
                        placeX -= dx; placeY -= dy;
                    }
                }

                // 5. Finally, Place Rook at Target (which is cleared or empty now)
                // But wait! If targetIdx was occupied by P1, P1 moved back.
                // So targetIdx is now free for Rook.
                this.board[targetIdx] = rook;

                rook.charge = 0;
                setTimeout(() => {
                    this.render();
                    this.endTurn();
                }, 300);
            }
        }

        executeJetSkill(idx) {
            const cells = document.getElementById('board').children;
            if(cells[idx].classList.contains('highlight-skill-target')) {
                Sound.jet();
                this.animating = true;
                this.showJetAnimation(this.selectedIdx, idx, 'blue');
                setTimeout(() => {
                    this.animating = false;
                    const victim = this.board[idx];
                    
                    // IMMUNITY CHECK
                    if (victim.invincibleTurns > 0) {
                        Sound.metal();
                    } else {
                        this.addToGraveyard(victim);
                        this.board[idx] = null;
                    }
                    
                    this.board[this.selectedIdx].charge = 0;
                    this.render();
                    this.endTurn();
                }, 400); 
            } else {
                const p = this.board[idx];
                if (p && p.revealed && p.r === 7) { Sound.fail(); this.showMsg("BOSSå…ç–«æ°´æŸ±ï¼"); } else Sound.error();
            }
        }

        executeCannonSkill(centerIdx) {
            const cells = document.getElementById('board').children;
            if(!cells[centerIdx].classList.contains('highlight-cannon-target')) {
                Sound.error(); return;
            }

            const cx = centerIdx % 4;
            const cy = Math.floor(centerIdx / 4);
            const affectedIndices = [];
            let pieceCount = 0;

            for(let dy=-1; dy<=1; dy++) {
                for(let dx=-1; dx<=1; dx++) {
                    const nx=cx+dx, ny=cy+dy;
                    if(nx>=0 && nx<4 && ny>=0 && ny<8) {
                        const idx = ny*4+nx;
                        affectedIndices.push(idx);
                        if(this.board[idx] !== null) pieceCount++;
                    }
                }
            }

            if(pieceCount < 3) {
                Sound.fail();
                this.showMsg("ç›®æ¨™æ•¸é‡ä¸è¶³å®šä½å¤±æ•—");
                return;
            }

            Sound.jet();
            affectedIndices.forEach(idx => {
                this.showJetAnimation(this.selectedIdx, idx, 'orange');
            });

            setTimeout(() => {
                this.showExplosionAnimation(centerIdx, () => {
                    const attacker = this.board[this.selectedIdx];
                    affectedIndices.forEach(idx => {
                        const p = this.board[idx];
                        if(!p) return;
                        
                        let destroyed = false;
                        if(p.revealed) { destroyed = true; } 
                        else { p.revealed = true; if(p.color !== attacker.color) destroyed = true; }
                        
                        if(p.invincibleTurns > 0) destroyed = false;

                        if(destroyed) { this.addToGraveyard(p); this.board[idx] = null; }
                    });
                    attacker.charge = 0;
                    this.render();
                    this.endTurn();
                });
            }, 300);
        }

        executeStormSkill(targetIdx) {
            const cells = document.getElementById('board').children;
            if (!cells[targetIdx].classList.contains('highlight-storm-target')) {
                Sound.error(); return;
            }

            const originIdx = this.selectedIdx;
            const ox = originIdx % 4;
            const oy = Math.floor(originIdx / 4);
            const tx = targetIdx % 4;
            const ty = Math.floor(targetIdx / 4);

            let dx = tx - ox;
            let dy = ty - oy;
            if(dx !== 0) dx = dx / Math.abs(dx);
            if(dy !== 0) dy = dy / Math.abs(dy);

            this.showStormAnimation(originIdx, targetIdx, () => {
                const attacker = this.board[originIdx];
                let cx = ox + dx;
                let cy = oy + dy;

                while(cx >= 0 && cx < 4 && cy >= 0 && cy < 8) {
                    const idx = cy * 4 + cx;
                    const p = this.board[idx];
                    
                    if(p) {
                        let destroyed = false;
                        if (!p.revealed) p.revealed = true;
                        if (p.color !== attacker.color) destroyed = true;
                        
                        if(p.invincibleTurns > 0) destroyed = false;

                        if(destroyed) {
                            this.addToGraveyard(p);
                            this.board[idx] = null;
                        }
                    }
                    cx += dx; cy += dy;
                }

                attacker.charge = 0;
                this.render();
                this.endTurn();
            });
        }

        executeMove(from, to) {
            const p = this.board[from];
            if(p.isFF && p.charge < 3) p.charge++;
            if(p.r === 2 && this.mode === 'SPECIAL' && p.charge < 5) p.charge++;
            if(p.r === 7 && this.mode === 'SPECIAL' && p.charge < 7) p.charge++;
            if(p.r === 6 && this.mode === 'SPECIAL' && p.charge < 6) p.charge++;
            if(p.r === 5 && this.mode === 'SPECIAL' && p.charge < 5) p.charge++;
            if(p.r === 4 && this.mode === 'SPECIAL' && p.charge < 3) p.charge++;
            if(p.r === 3 && this.mode === 'SPECIAL' && p.charge < 1) p.charge++;

            this.board[to] = p;
            this.board[from] = null;
            Sound.move();
            this.render();
            this.endTurn();
        }

        executeAttack(from, to, isDark) {
            const attacker = this.board[from];
            if(attacker.isFF && attacker.charge < 3) attacker.charge++;
            if(attacker.r === 2 && this.mode === 'SPECIAL' && attacker.charge < 5) attacker.charge++;
            if(attacker.r === 7 && this.mode === 'SPECIAL' && attacker.charge < 7) attacker.charge++;
            if(attacker.r === 6 && this.mode === 'SPECIAL' && attacker.charge < 6) attacker.charge++;
            if(attacker.r === 5 && this.mode === 'SPECIAL' && attacker.charge < 5) attacker.charge++;
            if(attacker.r === 4 && this.mode === 'SPECIAL' && attacker.charge < 3) attacker.charge++;
            if(attacker.r === 3 && this.mode === 'SPECIAL' && attacker.charge < 1) attacker.charge++;

            if(isDark) {
                const target = this.board[to];
                target.revealed = true;
                this.render(); 
                if(target.color === attacker.color) {
                    Sound.fail(); this.showMsg("æ˜¯è‡ªå·±äºº"); setTimeout(() => this.endTurn(), 500); return;
                }
                let canKill = this.canPieceKill(attacker, target);
                if(canKill) setTimeout(() => this.performCapture(from, to), 500);
                else { 
                    Sound.fail(); 
                    this.shakePiece(from); 
                    if(target.invincibleTurns > 0) {
                        Sound.metal(); this.showMsg("é‡‘å‰›ä¸å£ï¼ç„¡æ³•æ”»æ“Š");
                    } else {
                        this.showMsg("æ‰“ä¸é"); 
                    }
                    setTimeout(() => this.endTurn(), 500); 
                }
            } else {
                this.performCapture(from, to);
            }
        }

        performCapture(from, to) {
            const victim = this.board[to];
            if(victim.invincibleTurns > 0) {
                Sound.metal(); this.showMsg("é‡‘å‰›ä¸å£ï¼ç„¡æ³•æ”»æ“Š"); return;
            }

            const killer = this.board[from];
            this.addToGraveyard(victim);
            Sound.capture();
            this.board[to] = killer;
            this.board[from] = null;
            this.render();
            this.startChainCapture(to);
        }

        startChainCapture(idx) {
            if(this.hasTargets(idx)) {
                this.isChainCapturing = true; this.chainIdx = idx; this.selectedIdx = idx;
                this.render(); this.highlightTargets(idx, true);
                document.getElementById('btn-end-capture').style.display = 'flex';
                this.showMsg("é€£åƒï¼");
            } else { setTimeout(() => this.endTurn(), 300); }
        }

        hasTargets(idx) {
            for(let i=0; i<32; i++) {
                if(i===idx) continue;
                const res = this.checkAttack(idx, i);
                if(res.reachable && (res.valid || res.isDark)) return true;
            }
            return false;
        }

        canPieceKill(attacker, target) {
            if (target.invincibleTurns > 0) return false;

            if(attacker.isFF) return target.r !== 7;
            if(target.isFF) return attacker.r === 7 || attacker.r === 2; 
            if(attacker.r === 2) return true; 
            if(attacker.r === 7 && target.r === 1) return false; 
            if(attacker.r === 1 && target.r === 7) return true; 
            return attacker.r >= target.r;
        }

        checkAttack(from, to) {
            const attacker = this.board[from];
            const target = this.board[to];
            if(!target) return {reachable:false};
            const isDark = !target.revealed;
            const dist = this.getDist(from, to);
            let reachable = false;

            if(attacker.r === 2) { 
                const x1=from%4, y1=Math.floor(from/4);
                const x2=to%4, y2=Math.floor(to/4);
                if(x1===x2 || y1===y2) {
                    let screens = 0;
                    const minX=Math.min(x1,x2), maxX=Math.max(x1,x2);
                    const minY=Math.min(y1,y2), maxY=Math.max(y1,y2);
                    if(y1===y2) { for(let k=minX+1;k<maxX;k++) if(this.board[y1*4+k]) screens++; }
                    else { for(let k=minY+1;k<maxY;k++) if(this.board[k*4+x1]) screens++; }
                    if(screens === 1) reachable = true;
                }
            } else { 
                // Normal distance check
                if(dist === 1) reachable = true; 
                
                // Horse Diagonal Ability (Rank 3, Charge >= 1)
                if (attacker.r === 3 && attacker.charge >= 1) {
                    const x1=from%4, y1=Math.floor(from/4);
                    const x2=to%4, y2=Math.floor(to/4);
                    if (Math.abs(x1-x2) <= 1 && Math.abs(y1-y2) <= 1) {
                        reachable = true;
                    }
                }
            }

            if(!reachable) return {reachable:false};
            if(isDark) return {reachable:true, valid:true, isDark:true};
            if(target.color === attacker.color) return {reachable:true, valid:false, isDark:false};
            return {reachable:true, valid:this.canPieceKill(attacker, target), isDark:false};
        }

        getDist(i1, i2) { return Math.abs((i1%4)-(i2%4)) + Math.abs(Math.floor(i1/4)-Math.floor(i2/4)); }
        
        isAdjacent(i1, i2) { 
            const p = this.board[i1];
            const x1=i1%4, y1=Math.floor(i1/4);
            const x2=i2%4, y2=Math.floor(i2/4);
            if (Math.abs(x1-x2) + Math.abs(y1-y2) === 1) return true;
            if (p && p.r === 3 && p.charge >= 1) {
                if (Math.abs(x1-x2) <= 1 && Math.abs(y1-y2) <= 1) return true;
            }
            return false;
        }
        
        shakePiece(idx) { const el = document.getElementById(`piece-${idx}`); if(el) { el.classList.remove('fail-shake'); void el.offsetWidth; el.classList.add('fail-shake'); } }

        addToGraveyard(p) {
            const div = document.createElement('div');
            div.className = `graveyard-piece ${p.color} ${p.isFF ? 'ff-dead' : ''}`;
            if (p.isFF) { div.innerText = p.color === 'red' ? 'ğŸ‘¨â€ğŸš’' : 'ğŸ¥·'; } 
            else { div.innerText = p.n; }
            if(p.color === 'red') document.getElementById('graveyard-red-strip').appendChild(div);
            else document.getElementById('graveyard-black-strip').appendChild(div);
        }

        highlightTargets(idx, isChain=false) {
            const cells = document.getElementById('board').children;
            for(let i=0; i<32; i++) {
                if(i===idx) continue;
                const p = this.board[i];
                if(!p) {
                    if(!isChain && this.isAdjacent(idx, i)) cells[i].classList.add('highlight-move');
                    continue;
                }
                const res = this.checkAttack(idx, i);
                if(res.reachable) {
                    if(res.isDark) cells[i].classList.add('highlight-dark-attack');
                    else if(res.valid) cells[i].classList.add('highlight-capture');
                }
            }
        }

        resetControls() {
            document.getElementById('btn-skill-jet').style.display = 'none';
            document.getElementById('btn-skill-cannon').style.display = 'none';
            document.getElementById('btn-skill-storm').style.display = 'none';
            document.getElementById('btn-skill-gold').style.display = 'none';
            document.getElementById('btn-skill-elephant').style.display = 'none';
            document.getElementById('btn-skill-nitro').style.display = 'none';
            
            document.getElementById('btn-pawn-swap').style.display = 'none';
            document.getElementById('btn-pawn-rez').style.display = 'none';
            document.getElementById('btn-pawn-equip').style.display = 'none';
            document.getElementById('btn-cancel').style.display = 'none';
            document.getElementById('btn-end-capture').style.display = 'none';
        }

        cancelAction() {
            this.selectedIdx = -1;
            this.skillMode = null;
            this.resetControls();
            this.render();
        }

        endTurn() {
            this.board.forEach(p => {
                if (p && p.invincibleTurns > 0) p.invincibleTurns--;
            });

            this.selectedIdx = -1;
            this.isChainCapturing = false;
            this.chainIdx = -1;
            this.skillMode = null;
            this.turn = (this.turn === 'red') ? 'black' : 'red';
            this.updateUI();
            this.resetControls();
            this.render();
            this.checkWin();
        }

        updateUI(msg) {
            const disp = document.getElementById('turn-display');
            disp.innerText = msg || (this.turn === 'red' ? 'ç´…æ–¹å›åˆ' : 'é»‘æ–¹å›åˆ');
            disp.className = 'turn-indicator';
            if(this.turn === 'red') disp.classList.add('active-red');
            if(this.turn === 'black') disp.classList.add('active-black');
        }

        showMsg(txt) {
            const el = document.getElementById('message-overlay');
            el.innerText = txt; el.style.opacity = 1;
            setTimeout(()=>el.style.opacity=0, 1000);
        }

        checkWin() {
            let r=0, b=0;
            this.board.forEach(p => { if(p) p.color==='red' ? r++ : b++; });
            if(r===0 || b===0) {
                this.gameOver = true;
                document.getElementById('winner-title').innerText = r===0 ? "é»‘æ–¹ç²å‹ï¼" : "ç´…æ–¹ç²å‹ï¼";
                document.getElementById('game-over-screen').classList.remove('hidden-screen');
                Sound.win();
            }
        }
    }

    const game = new DarkChess();
    
    // Window Resize Handler to update fonts
    window.addEventListener('resize', () => {
        game.render();
    });
</script>
</body>
</html>

