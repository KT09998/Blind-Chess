<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>æš—æ£‹ - æ¶ˆé˜²æ “èˆ‡ç«ç„°ç‚® (ç‰¹æ•ˆç‰ˆ)</title>
    <style>
        :root {
            --board-bg: #e6cca0;
            --grid-line: #5c4033;
            --piece-red: #c0392b;
            --piece-black: #2c3e50;
            --valid-capture: rgba(231, 76, 60, 0.6);
            --valid-skill: rgba(52, 152, 219, 0.6);
            --valid-cannon-skill: rgba(230, 126, 34, 0.7);
            --valid-dark-attack: rgba(230, 126, 34, 0.6);
            --ui-bg: #2c3e50;
            --panel-bg: rgba(0, 0, 0, 0.3);
            --safe-bottom: env(safe-area-inset-bottom, 20px);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, "bikai", "KaiTi", "DFKai-SB", serif;
            background-color: var(--ui-bg);
            margin: 0; padding: 0;
            display: flex; flex-direction: column; align-items: center;
            height: 100vh; height: 100dvh; 
            overflow: hidden; color: white;
            user-select: none; -webkit-user-select: none;
            touch-action: manipulation;
        }

        /* --- Screens --- */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(44, 62, 80, 0.98);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 1000; transition: opacity 0.3s;
        }
        .hidden-screen { display: none !important; opacity: 0; pointer-events: none; }

        h1 { font-size: 2rem; margin-bottom: 1.5rem; color: #f1c40f; text-shadow: 2px 2px 0 #000; text-align: center; }
        
        .menu-btn {
            padding: 15px 0; width: 80%; max-width: 300px;
            font-size: 1.2rem; margin: 10px 0; border: none; border-radius: 50px;
            background: #e74c3c; color: white; cursor: pointer; box-shadow: 0 5px 0 #c0392b;
            font-family: inherit; font-weight: bold;
        }
        .menu-btn:active { transform: translateY(5px); box-shadow: none; }
        .btn-blue { background: #3498db; box-shadow: 0 5px 0 #2980b9; }
        .btn-green { background: #2ecc71; box-shadow: 0 5px 0 #27ae60; }

        /* --- Game Layout --- */
        #game-container {
            display: flex; flex-direction: column; width: 100%; height: 100%;
            max-width: 600px; margin: 0 auto; padding: 5px 0 0 0; box-sizing: border-box;
        }

        .top-panel {
            flex: 0 0 auto; display: flex; flex-direction: column; width: 100%;
            padding: 0 10px; box-sizing: border-box; gap: 5px; z-index: 10;
        }

        #status-bar { width: 100%; display: flex; justify-content: center; padding: 2px 0; }

        .turn-indicator {
            padding: 5px 20px; border-radius: 20px; background: #444; color: #ccc;
            border: 2px solid transparent; min-width: 100px; text-align: center;
            font-size: 1rem; font-weight: bold; box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        .turn-indicator.active-red { background: var(--piece-red); color: white; border-color: #e74c3c; box-shadow: 0 0 10px var(--piece-red); }
        .turn-indicator.active-black { background: black; color: white; border-color: #7f8c8d; box-shadow: 0 0 10px white; }

        .graveyard-strip {
            width: 100%; height: 40px; background: var(--panel-bg);
            border: 1px solid #5c4033; border-radius: 8px;
            display: flex; align-items: center; padding: 0 5px;
            overflow-x: auto; white-space: nowrap; gap: 5px; box-sizing: border-box;
        }
        .graveyard-strip::-webkit-scrollbar { height: 0px; }

        .graveyard-piece {
            width: 28px; height: 28px; border-radius: 50%;
            background-color: #f3e5ab; color: #000;
            display: flex; justify-content: center; align-items: center;
            font-size: 16px; font-weight: bold; border: 2px solid #8b4513;
            flex-shrink: 0; position: relative;
        }
        .graveyard-piece.red { color: var(--piece-red); border-color: var(--piece-red); }
        .graveyard-piece.black { color: var(--piece-black); border-color: var(--piece-black); }
        .graveyard-piece.ff-dead { border: 3px double; font-size: 18px; }
        .graveyard-piece.ff-dead::after { content: 'ğŸ’€'; position: absolute; font-size: 10px; bottom: -4px; right: -4px; }

        .board-wrapper {
            flex: 1 1 auto; min-height: 0; display: flex;
            justify-content: center; align-items: center; width: 100%;
            padding: 5px; box-sizing: border-box; overflow: hidden;
        }

        #board {
            height: 100%; width: auto; max-width: 100%; aspect-ratio: 4/8;
            background-color: var(--board-bg);
            border: 4px solid #5c4033; border-radius: 8px;
            display: grid; grid-template-columns: repeat(4, 1fr); grid-template-rows: repeat(8, 1fr);
            gap: 1px; box-shadow: 0 5px 15px rgba(0,0,0,0.6); position: relative;
        }

        .cell {
            position: relative; border: 1px solid rgba(92, 64, 51, 0.2);
            display: flex; justify-content: center; align-items: center; cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .piece {
            width: 90%; height: 90%; border-radius: 50%;
            background: #f3e5ab; border: 2px solid #8b4513;
            box-shadow: inset 2px 2px 5px rgba(255,255,255,0.4), 1px 1px 3px rgba(0,0,0,0.4);
            display: flex; justify-content: center; align-items: center;
            font-size: clamp(1rem, 4vh, 2rem); font-weight: bold; user-select: none;
            position: absolute; z-index: 10;
            transition: transform 0.2s, top 0.2s, left 0.2s;
        }
        .piece.hidden {
            background: radial-gradient(circle, #8b4513 30%, #5c4033 100%);
            color: transparent; border-color: #3e2723;
        }
        .piece.hidden::after { content: "âœ¦"; color: rgba(255,255,255,0.15); font-size: 1.2rem; }
        .piece.red { color: var(--piece-red); }
        .piece.black { color: var(--piece-black); }
        .piece.selected { transform: scale(1.15); z-index: 20; box-shadow: 0 0 0 3px #f1c40f, 0 0 10px #f1c40f; }

        .piece.firefighter {
            border-width: 3px; display: flex; flex-direction: column; justify-content: center; align-items: center; line-height: 1;
        }
        .piece.firefighter.red { background-color: #fff0f0; border-color: #c0392b; color: #c0392b; }
        .piece.firefighter.red::before { content: 'ğŸ”¥'; font-size: 0.7rem; position: absolute; top: 1px; right: 1px; }
        .piece.firefighter.black { background-color: #dcdde1; border-color: #2c3e50; border-style: double; color: #2c3e50; }
        .piece.firefighter.black::before { content: 'ğŸ’§'; font-size: 0.7rem; position: absolute; top: 1px; left: 1px; }
        
        .charge-bar { position: absolute; bottom: 5%; display: flex; gap: 2px; height: 6px; align-items: center; }
        .charge-pip { width: 5px; height: 5px; border-radius: 50%; background: #ccc; border: 1px solid #777; }
        .charge-pip.on { background: #3498db; border-color: #2980b9; box-shadow: 0 0 3px #3498db; }
        .charge-pip.cannon-on { background: #e67e22; border-color: #d35400; box-shadow: 0 0 3px #e67e22; }

        /* --- Animations --- */
        .jet-beam {
            position: absolute; height: 12px; background: linear-gradient(90deg, rgba(52, 152, 219, 0.9), rgba(133, 193, 233, 0.5) 80%, rgba(255,255,255,0));
            box-shadow: 0 0 10px #3498db, 0 0 20px #2980b9; border-radius: 6px; z-index: 999;
            transform-origin: left center; pointer-events: none; opacity: 0; transition: opacity 0.1s;
        }

        .fire-beam {
            position: absolute; height: 20px; 
            background: linear-gradient(90deg, #ff4500, #ff8c00 70%, rgba(255,255,0,0));
            box-shadow: 0 0 15px #ff4500, 0 0 30px #ffa500;
            border-radius: 10px; z-index: 999;
            transform-origin: left center; pointer-events: none; opacity: 0; transition: opacity 0.1s;
        }

        .explosion-effect {
            position: absolute; width: 300%; height: 300%; 
            top: -100%; left: -100%;
            background: radial-gradient(circle, rgba(255,69,0,0.8) 10%, rgba(255,165,0,0.6) 40%, rgba(0,0,0,0) 70%);
            z-index: 998; pointer-events: none;
            animation: explode 0.6s ease-out forwards;
            border-radius: 50%;
        }
        @keyframes explode {
            0% { transform: scale(0); opacity: 0; }
            30% { transform: scale(1); opacity: 1; }
            100% { transform: scale(1.2); opacity: 0; }
        }

        .teleport-orb {
            position: absolute; border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.9) 10%, rgba(155, 89, 182, 0.8) 60%, rgba(142, 68, 173, 0) 70%);
            box-shadow: 0 0 15px rgba(155, 89, 182, 0.8), 0 0 30px rgba(142, 68, 173, 0.4);
            z-index: 998; pointer-events: none; transition: all 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55); mix-blend-mode: screen;
        }

        .resurrect-soul {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center; font-size: 2rem;
            z-index: 1000; pointer-events: none; animation: riseFade 1.2s forwards ease-in-out;
            text-shadow: 0 0 10px #9b59b6, 0 0 20px #8e44ad;
        }
        @keyframes riseFade {
            0% { transform: translateY(0) scale(0.5); opacity: 0; }
            20% { opacity: 1; transform: translateY(-10px) scale(1.2); }
            80% { opacity: 0.8; }
            100% { transform: translateY(-60px) scale(1.5); opacity: 0; }
        }

        .highlight-move::before { content: ''; position: absolute; width: 20%; height: 20%; background: #2ecc71; border-radius: 50%; opacity: 0.8; }
        .highlight-capture { background-color: var(--valid-capture); box-shadow: inset 0 0 10px #c0392b; }
        .highlight-dark-attack { background-color: var(--valid-dark-attack); box-shadow: inset 0 0 10px #d35400; }
        .highlight-skill-target { background-color: rgba(52, 152, 219, 0.6); box-shadow: inset 0 0 15px #3498db; cursor: crosshair; animation: pulse-blue 1s infinite; }
        .highlight-cannon-target { background-color: var(--valid-cannon-skill); box-shadow: inset 0 0 15px #e67e22; cursor: crosshair; animation: pulse-orange 1s infinite; }
        @keyframes pulse-blue { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }
        @keyframes pulse-orange { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }
        .fail-shake { animation: shake 0.4s; }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }

        /* 3. Controls */
        #bottom-graveyard-container { flex: 0 0 auto; margin-bottom: 5px; }

        #controls-area {
            flex: 0 0 auto; position: relative; width: 100%;
            background: rgba(30, 30, 30, 0.8); backdrop-filter: blur(5px);
            border-top: 1px solid #555; padding: 8px;
            padding-bottom: calc(8px + var(--safe-bottom));
            box-sizing: border-box; display: flex; flex-wrap: wrap; justify-content: center; gap: 8px; z-index: 100; min-height: 60px;
        }

        .action-btn {
            padding: 10px 15px; font-size: 0.95rem; border: none; border-radius: 10px; cursor: pointer;
            color: white; display: none; box-shadow: 0 3px 0 rgba(0,0,0,0.3);
            align-items: center; justify-content: center; font-weight: bold; flex-grow: 1; max-width: 48%;
        }
        .action-btn:active { transform: translateY(3px); box-shadow: none; }
        
        #btn-skill-jet { background: #3498db; }
        #btn-skill-cannon { background: #d35400; }
        #btn-skill-jet.disabled, #btn-skill-cannon.disabled { background: #7f8c8d; opacity: 0.6; pointer-events: none; }
        
        #btn-pawn-swap { background: #9b59b6; }
        #btn-pawn-rez { background: #f1c40f; color: #333; }
        #btn-pawn-equip { background: #27ae60; }
        #btn-cancel { background: #e74c3c; max-width: 30%; }
        #btn-end-capture { background: #e67e22; }
        #btn-reset { background: #95a5a6; max-width: 20%; font-size: 0.9rem; padding: 5px; }

        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 2000;
            display: flex; justify-content: center; align-items: center; padding: 20px; box-sizing: border-box;
        }
        .modal-content {
            background: #fff; color: #333; padding: 20px; border-radius: 15px;
            text-align: center; width: 100%; max-width: 350px; border: 5px solid #f1c40f;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
        }
        .modal-btns { display: flex; gap: 10px; justify-content: center; margin-top: 20px; }
        
        #message-overlay {
            position: fixed; top: 40%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9); color: #f1c40f; padding: 15px 30px; border-radius: 50px;
            font-size: 1.5rem; pointer-events: none; opacity: 0; transition: opacity 0.3s; z-index: 1500;
            white-space: nowrap; border: 2px solid #f1c40f;
        }

        /* Desktop */
        @media (min-width: 768px) {
            #game-container { flexDirection: row; alignItems: center; justifyContent: center; maxWidth: 1000px; padding: 20px; }
            .top-panel { width: 15%; height: 80%; justifyContent: flex-start; }
            #status-bar { marginBottom: 20px; }
            .graveyard-strip { width: 100%; height: auto; flex: 1; flexDirection: column; overflowX: hidden; overflowY: auto; padding: 10px 0; }
            .board-wrapper { width: 60%; height: 90vh; }
            #board { height: 100%; maxHeight: 800px; width: auto; aspectRatio: 4/8; }
            .piece { fontSize: 2.5rem; }
            #bottom-graveyard-container { order: 3; width: 15%; height: 80%; marginBottom: 0; }
            #controls-area { position: absolute; bottom: 20px; width: auto; background: transparent; border: none; boxShadow: none; }
            .action-btn { maxWidth: 200px; }
        }
    </style>
</head>
<body>

<div id="start-screen" class="screen">
    <h1>æš—æ£‹å°æ±º</h1>
    <button class="menu-btn" onclick="game.startGame('STANDARD')">ç¶“å…¸é€£åƒç‰ˆ</button>
    <button class="menu-btn btn-blue" onclick="game.startGame('SPECIAL')">ç‰¹æ®Šæ¨¡å¼ï¼šæ¶ˆé˜²æ “èˆ‡ç«ç„°ç‚®</button>
</div>

<div id="game-over-screen" class="screen hidden-screen">
    <h1 id="winner-title">éŠæˆ²çµæŸ</h1>
    <button class="menu-btn btn-green" onclick="game.resetToMenu()">é‡æ–°éŠç©</button>
</div>

<div id="promotion-modal" class="modal-overlay hidden-screen">
    <div class="modal-content">
        <h2 style="margin:0 0 10px 0;">ğŸš’ ç™¼ç¾è£å‚™ï¼</h2>
        <p style="font-size:1.1rem;">æ˜¯å¦è®“é€™åå°å…µç©¿ä¸Šæ¶ˆé˜²è£å‚™ï¼Ÿ</p>
        <div style="background:#eee; padding:10px; border-radius:8px; margin:10px 0; font-size:0.9rem; text-align:left;">
            <strong>èƒ½åŠ›ï¼š</strong>æ¯”å°‡å°ã€æ¯”å£«å¤§<br>
            <strong>æŠ€èƒ½ï¼š</strong>æ°´æŸ±å™´å°„ã€æ›ä½ã€å¾©æ´»<br>
            <hr style="margin:5px 0; border:0; border-top:1px solid #ccc;">
            <strong>ğŸ’¥ ç‚®å…µæ–°æŠ€èƒ½ï¼š</strong><br>
            ç«ç„°å™´å°„ (é›†æ»¿5æ°£)ï¼šè½Ÿç‚¸ç›®æ¨™åŠå‘¨åœï¼Œéœ€ç›®æ¨™å€æœ‰3æ£‹ä»¥ä¸Šã€‚
        </div>
        <div class="modal-btns">
            <button class="action-btn btn-green" style="display:flex; background:#2ecc71;" onclick="game.confirmPromotion(true)">âœ… ç©¿è£å‚™</button>
            <button class="action-btn" style="display:flex; background:#95a5a6;" onclick="game.confirmPromotion(false)">âŒ ä¿æŒåŸç‹€</button>
        </div>
    </div>
</div>

<div id="game-container">
    <div class="top-panel" id="top-panel">
        <div id="status-bar">
            <div id="turn-display" class="turn-indicator">æº–å‚™é–‹å§‹</div>
        </div>
        <div class="graveyard-strip" id="graveyard-red-strip"></div>
    </div>

    <div class="board-wrapper">
        <div id="board"></div>
    </div>

    <div class="top-panel" id="bottom-graveyard-container">
        <div class="graveyard-strip" id="graveyard-black-strip"></div>
    </div>

    <div id="controls-area">
        <button id="btn-skill-jet" class="action-btn" onclick="game.activateSkill('JET')">ğŸŒŠ æ°´æŸ±å™´å°„</button>
        <button id="btn-skill-cannon" class="action-btn" onclick="game.activateSkill('CANNON_FIRE')">ğŸ”¥ ç«ç„°å™´å°„</button>
        
        <button id="btn-pawn-swap" class="action-btn" onclick="game.pawnAction('SWAP')">ğŸ”„ èˆ‡å¤§å“¥æ›ä½</button>
        <button id="btn-pawn-rez" class="action-btn" onclick="game.pawnAction('RESURRECT')">âš°ï¸ çŠ§ç‰²å¬å–š</button>
        <button id="btn-pawn-equip" class="action-btn" onclick="game.pawnAction('EQUIP')">ğŸ› ï¸ è£å‚™æ¶ˆé˜²æ “</button>
        
        <button id="btn-end-capture" class="action-btn" onclick="game.endTurn()">â¹ åœæ­¢é€£åƒ</button>
        <button id="btn-cancel" class="action-btn" onclick="game.cancelAction()">âŒ å–æ¶ˆ</button>
        <button id="btn-reset" class="action-btn" style="display:flex;" onclick="game.resetToMenu()">âŸ²</button>
    </div>
</div>

<div id="message-overlay"></div>

<script>
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const Sound = {
        play: (freq, type, dur, vol=0.1) => {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(vol, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + dur);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + dur);
        },
        flip: () => Sound.play(600, 'square', 0.08),
        move: () => Sound.play(150, 'triangle', 0.1),
        capture: () => Sound.play(100, 'sawtooth', 0.2, 0.2),
        error: () => Sound.play(80, 'sawtooth', 0.2),
        fail: () => { Sound.play(150, 'sawtooth', 0.1); setTimeout(()=>Sound.play(100, 'sawtooth', 0.1), 100); },
        skill: () => { [400, 600, 800].forEach((f,i) => setTimeout(()=>Sound.play(f,'sine',0.2), i*100)); },
        jet: () => {
             if(audioCtx.state === 'suspended') audioCtx.resume();
             const bufferSize = audioCtx.sampleRate * 0.5;
             const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
             const data = buffer.getChannelData(0);
             for(let i=0; i<bufferSize; i++) data[i] = Math.random() * 2 - 1;
             const noise = audioCtx.createBufferSource(); noise.buffer = buffer;
             const gain = audioCtx.createGain(); gain.gain.setValueAtTime(0.3, audioCtx.currentTime); 
             gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime+0.5);
             noise.connect(gain); gain.connect(audioCtx.destination); noise.start();
        },
        explosion: () => {
             if(audioCtx.state === 'suspended') audioCtx.resume();
             const bufferSize = audioCtx.sampleRate * 0.8;
             const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
             const data = buffer.getChannelData(0);
             for(let i=0; i<bufferSize; i++) data[i] = (Math.random() * 2 - 1) * (1 - i/bufferSize);
             const noise = audioCtx.createBufferSource(); noise.buffer = buffer;
             const gain = audioCtx.createGain(); 
             // Low pass filter to make it sound like an explosion
             const filter = audioCtx.createBiquadFilter();
             filter.type = "lowpass"; filter.frequency.value = 800;
             gain.gain.setValueAtTime(1.0, audioCtx.currentTime); 
             gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime+0.8);
             noise.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination); 
             noise.start();
        },
        teleport: () => {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(200, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.5);
            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + 0.5);
        },
        win: () => { [300, 400, 500, 600].forEach((f,i) => setTimeout(()=>Sound.play(f,'sine',0.3), i*150)); }
    };

    const PIECES = {
        RED: [
            {id:'r7',n:'å¸¥',r:7,c:1},{id:'r6',n:'ä»•',r:6,c:2},{id:'r5',n:'ç›¸',r:5,c:2},
            {id:'r4',n:'ä¿¥',r:4,c:2},{id:'r3',n:'å‚Œ',r:3,c:2},{id:'r2',n:'ç‚®',r:2,c:2},
            {id:'r1',n:'å…µ',r:1,c:5}
        ],
        BLACK: [
            {id:'b7',n:'å°‡',r:7,c:1},{id:'b6',n:'å£«',r:6,c:2},{id:'b5',n:'è±¡',r:5,c:2},
            {id:'b4',n:'è»Š',r:4,c:2},{id:'b3',n:'é¦¬',r:3,c:2},{id:'b2',n:'åŒ…',r:2,c:2},
            {id:'b1',n:'å’',r:1,c:5}
        ]
    };

    class DarkChess {
        constructor() {
            this.board = [];
            this.turn = null; 
            this.myColor = null; 
            this.selectedIdx = -1;
            this.mode = 'STANDARD';
            this.gameOver = false;
            this.isChainCapturing = false;
            this.chainIdx = -1;
            this.pendingPromoIdx = -1;
            this.pendingPromoCtx = false;
            this.isFirstMove = true;
            this.skillMode = null;
            this.animating = false;
        }

        startGame(mode) {
            this.mode = mode;
            document.getElementById('start-screen').classList.add('hidden-screen');
            this.init();
        }

        init() {
            let pool = [];
            // Init pieces. For Cannon (r=2), enable charging.
            PIECES.RED.forEach(p => { for(let i=0; i<p.c; i++) pool.push({...p, color:'red', revealed:false, isFF:false, charge:0}); });
            PIECES.BLACK.forEach(p => { for(let i=0; i<p.c; i++) pool.push({...p, color:'black', revealed:false, isFF:false, charge:0}); });
            
            for(let i=pool.length-1; i>0; i--){
                const j = Math.floor(Math.random()*(i+1));
                [pool[i], pool[j]] = [pool[j], pool[i]];
            }

            this.board = pool;
            this.turn = null;
            this.myColor = null;
            this.selectedIdx = -1;
            this.isChainCapturing = false;
            this.chainIdx = -1;
            this.isFirstMove = true;
            this.gameOver = false;
            this.skillMode = null;
            this.animating = false;
            
            document.getElementById('graveyard-red-strip').innerHTML = '';
            document.getElementById('graveyard-black-strip').innerHTML = '';
            
            this.render();
            this.updateUI("è«‹ç¿»ç‰Œæ±ºå®šå…ˆå¾Œæ‰‹");
            this.resetControls();
        }

        resetToMenu() {
            this.gameOver = false;
            document.getElementById('game-over-screen').classList.add('hidden-screen');
            document.getElementById('promotion-modal').classList.add('hidden-screen');
            document.getElementById('message-overlay').style.opacity = 0;
            document.getElementById('start-screen').classList.remove('hidden-screen');
            document.getElementById('board').innerHTML = '';
            document.getElementById('graveyard-red-strip').innerHTML = '';
            document.getElementById('graveyard-black-strip').innerHTML = '';
        }

        render() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            this.board.forEach((p, idx) => {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.id = `cell-${idx}`;
                cell.onclick = () => this.handleCellClick(idx);
                
                if(p) {
                    const el = document.createElement('div');
                    el.className = `piece ${p.color} ${p.revealed ? '':'hidden'} ${p.isFF ? 'firefighter':''}`;
                    el.id = `piece-${idx}`;
                    
                    if(p.revealed) {
                        if (p.isFF) {
                            el.innerText = p.color === 'red' ? 'ğŸ‘¨â€ğŸš’' : 'ğŸ¥·'; 
                        } else {
                            el.innerText = p.n;
                        }

                        // Charge Bar Logic
                        let maxCharge = 0;
                        if (p.isFF) maxCharge = 3;
                        else if (p.r === 2 && this.mode === 'SPECIAL') maxCharge = 5; // Cannon

                        if(maxCharge > 0) {
                            const bar = document.createElement('div');
                            bar.className = 'charge-bar';
                            for(let i=0; i<maxCharge; i++) {
                                const pip = document.createElement('div');
                                let onClass = 'on';
                                if (p.r === 2) onClass = 'cannon-on';
                                pip.className = `charge-pip ${i < p.charge ? onClass:''}`;
                                bar.appendChild(pip);
                            }
                            el.appendChild(bar);
                        }
                    }
                    if(this.selectedIdx === idx) el.classList.add('selected');
                    cell.appendChild(el);
                }
                boardEl.appendChild(cell);
            });
        }

        handleCellClick(idx) {
            if(this.gameOver || this.animating) return;
            const p = this.board[idx];

            if(this.skillMode === 'JET') {
                this.executeJetSkill(idx);
                return;
            }

            if(this.skillMode === 'CANNON_FIRE') {
                this.executeCannonSkill(idx);
                return;
            }

            if(this.isChainCapturing) {
                if(idx === this.chainIdx) return;
                if(p) {
                    const res = this.checkAttack(this.chainIdx, idx);
                    if(res.valid || res.isDark) {
                        this.executeAttack(this.chainIdx, idx, res.isDark);
                    } else {
                        Sound.error();
                        this.showMsg("ç„¡æ³•æ”»æ“Š");
                    }
                } else {
                    Sound.error();
                    this.showMsg("ä¸å¯èµ°ç©ºåœ°");
                }
                return;
            }

            // A. First Flip
            if(this.turn === null) {
                if(p && !p.revealed) this.performFirstFlip(idx);
                return;
            }

            // B. Selection
            if(p && p.revealed && p.color === this.turn) {
                this.selectPiece(idx);
                return;
            }

            // C. Action
            if(this.selectedIdx !== -1) {
                if(idx === this.selectedIdx) { this.cancelAction(); return; }
                
                if(!p) {
                    if(this.isAdjacent(this.selectedIdx, idx)) {
                        this.executeMove(this.selectedIdx, idx);
                    } else {
                        this.cancelAction();
                        Sound.error();
                    }
                    return;
                }

                const res = this.checkAttack(this.selectedIdx, idx);
                if(res.reachable) {
                    if(res.valid || res.isDark) {
                        this.executeAttack(this.selectedIdx, idx, res.isDark);
                    } else {
                        Sound.error();
                        this.shakePiece(this.selectedIdx);
                        this.showMsg("æ‰“ä¸éï¼");
                    }
                } else {
                    this.cancelAction();
                }
                return;
            }

            // D. Normal Flip
            if(p && !p.revealed) {
                this.performNormalFlip(idx);
            }
        }

        performFirstFlip(idx) {
            const p = this.board[idx];
            p.revealed = true;
            this.myColor = p.color;
            Sound.flip();
            this.render();

            if(this.mode === 'SPECIAL' && p.r === 1 && !this.hasFirefighterOnBoard(p.color)) {
                this.triggerPromotion(idx, true); 
            } else {
                this.turn = (p.color === 'red') ? 'black' : 'red';
                this.isFirstMove = true; 
                this.updateUI();
            }
        }

        performNormalFlip(idx) {
            const p = this.board[idx];
            p.revealed = true;
            Sound.flip();
            this.render();

            if(this.mode === 'SPECIAL' && p.r === 1 && p.color === this.turn && !this.hasFirefighterOnBoard(p.color)) {
                this.triggerPromotion(idx, false);
            } else {
                this.isFirstMove = false;
                this.endTurn();
            }
        }

        triggerPromotion(idx, isFirstMoveCtx) {
            this.pendingPromoIdx = idx;
            this.pendingPromoCtx = isFirstMoveCtx;
            document.getElementById('promotion-modal').classList.remove('hidden-screen');
        }

        confirmPromotion(yes) {
            document.getElementById('promotion-modal').classList.add('hidden-screen');
            if (this.pendingPromoIdx === -1 || !this.board[this.pendingPromoIdx]) {
                if (this.turn === null) this.init(); 
                return;
            }
            const p = this.board[this.pendingPromoIdx];
            if(yes) {
                p.isFF = true; p.r = 6.5; p.n = 'æ¶ˆé˜²æ “';
                Sound.skill();
                this.showMsg("æ¶ˆé˜²æ “ç™»å ´ï¼");
            }
            if (this.pendingPromoCtx) {
                this.turn = (p.color === 'red') ? 'black' : 'red';
                this.isFirstMove = true;
                this.updateUI();
                this.render();
            } else {
                this.isFirstMove = false;
                this.endTurn();
            }
            this.pendingPromoIdx = -1;
        }

        hasFirefighterOnBoard(color) { return this.board.some(p => p && p.color === color && p.isFF); }
        hasFirefighterInGraveyard(color) {
            const graveId = color === 'red' ? 'graveyard-red-strip' : 'graveyard-black-strip';
            return document.getElementById(graveId).innerHTML.includes('ff-dead');
        }

        selectPiece(idx) {
            this.cancelAction();
            this.selectedIdx = idx;
            const p = this.board[idx];
            Sound.flip();
            this.render();
            this.highlightTargets(idx);

            if(this.mode === 'SPECIAL') {
                const jetBtn = document.getElementById('btn-skill-jet');
                const cannonBtn = document.getElementById('btn-skill-cannon');
                const swapBtn = document.getElementById('btn-pawn-swap');
                const rezBtn = document.getElementById('btn-pawn-rez');
                const equipBtn = document.getElementById('btn-pawn-equip');
                const cancelBtn = document.getElementById('btn-cancel');

                if(p.isFF) {
                    jetBtn.style.display = 'flex'; 
                    if (p.charge < 3) {
                        jetBtn.classList.add('disabled');
                        jetBtn.innerText = `é›†æ°£ä¸­ (${p.charge}/3)`;
                    } else {
                        jetBtn.classList.remove('disabled');
                        jetBtn.innerText = `ğŸŒŠ æ°´æŸ±å™´å°„ (READY)`;
                    }
                    cancelBtn.style.display = 'flex';
                }
                else if (p.r === 2) { // Cannon
                    cannonBtn.style.display = 'flex';
                    if (p.charge < 5) {
                        cannonBtn.classList.add('disabled');
                        cannonBtn.innerText = `é›†æ°£ä¸­ (${p.charge}/5)`;
                    } else {
                        cannonBtn.classList.remove('disabled');
                        cannonBtn.innerText = `ğŸ”¥ ç«ç„°å™´å°„ (READY)`;
                    }
                    cancelBtn.style.display = 'flex';
                }
                else if (p.r === 1) { // Pawn
                    const hasFF = this.hasFirefighterOnBoard(p.color);
                    const hasDeadFF = this.hasFirefighterInGraveyard(p.color);
                    if (!hasFF && !hasDeadFF) equipBtn.style.display = 'flex';
                    if(hasFF) swapBtn.style.display = 'flex';
                    if(hasDeadFF) rezBtn.style.display = 'flex';
                    cancelBtn.style.display = 'flex';
                }
            }
        }

        activateSkill(type) {
            if (type === 'JET') {
                this.skillMode = 'JET';
                this.highlightJetTargets();
                document.getElementById('btn-skill-jet').style.display = 'none';
            }
            else if (type === 'CANNON_FIRE') {
                this.skillMode = 'CANNON_FIRE';
                this.highlightCannonTargets();
                document.getElementById('btn-skill-cannon').style.display = 'none';
            }
        }

        pawnAction(type) {
            const pawnIdx = this.selectedIdx;
            const pawn = this.board[pawnIdx];
            
            if (type === 'SWAP') {
                const ffIdx = this.board.findIndex(p => p && p.color === pawn.color && p.isFF);
                if (ffIdx !== -1) {
                    Sound.teleport();
                    this.showSwapAnimation(pawnIdx, ffIdx, () => {
                        this.board[pawnIdx] = this.board[ffIdx];
                        this.board[ffIdx] = pawn;
                        this.render();
                        this.endTurn();
                    });
                }
            } 
            else if (type === 'RESURRECT') {
                Sound.skill();
                this.showResurrectAnimation(pawnIdx, () => {
                    this.addToGraveyard(pawn);
                    const graveId = pawn.color === 'red' ? 'graveyard-red-strip' : 'graveyard-black-strip';
                    const ffEl = document.getElementById(graveId).querySelector('.ff-dead');
                    if(ffEl) ffEl.remove();

                    const newFF = { id: 'ff-'+Date.now(), color: pawn.color, revealed: true, isFF: true, r: 6.5, n: 'æ¶ˆé˜²æ “', charge: 0 };
                    this.board[pawnIdx] = newFF;
                    this.render();
                    this.endTurn();
                });
            }
            else if (type === 'EQUIP') {
                pawn.isFF = true; pawn.r = 6.5; pawn.n = 'æ¶ˆé˜²æ “';
                Sound.skill();
                this.showMsg("è£å‚™å®Œæˆï¼");
                this.render();
                this.endTurn();
            }
        }

        // --- Targeting Logic ---

        highlightJetTargets() {
            const cells = document.getElementById('board').children;
            const origin = this.selectedIdx;
            const ox=origin%4, oy=Math.floor(origin/4);
            const dirs = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
            this.showMsg("é¸æ“‡å°„æ“Šç›®æ¨™ (å°‡å¸¥å…ç–«)");
            dirs.forEach(d => {
                let cx=ox+d[0], cy=oy+d[1];
                while(cx>=0 && cx<4 && cy>=0 && cy<8) {
                    const idx = cy*4+cx;
                    const p = this.board[idx];
                    if(p) {
                        if(p.revealed && p.color !== this.turn && p.r !== 7) {
                            cells[idx].classList.add('highlight-skill-target');
                        }
                        break; 
                    }
                    cx+=d[0]; cy+=d[1];
                }
            });
        }

        highlightCannonTargets() {
            const cells = document.getElementById('board').children;
            const origin = this.selectedIdx;
            this.showMsg("é¸æ“‡è½Ÿç‚¸ä¸­å¿ƒ (éœ€3x3å…§æœ‰3å­)");
            
            // Cannon follows standard capture rules for targeting: must jump over 1 piece
            for(let i=0; i<32; i++) {
                if(i === origin) continue;
                // Reuse checkAttack logic which handles cannon jump logic correctly (screens === 1)
                const res = this.checkAttack(origin, i);
                if (res.reachable && (res.valid || res.isDark)) {
                    // It's a valid "jump" target location.
                    cells[i].classList.add('highlight-cannon-target');
                }
            }
        }

        // --- Animations ---

        createOrb(cell) {
            const r = cell.getBoundingClientRect();
            const boardR = document.getElementById('board').getBoundingClientRect();
            const orbSize = r.width * 0.8;
            const orb = document.createElement('div');
            orb.className = 'teleport-orb';
            orb.style.width = orbSize + 'px';
            orb.style.height = orbSize + 'px';
            const left = (r.left - boardR.left) + (r.width - orbSize) / 2;
            const top = (r.top - boardR.top) + (r.height - orbSize) / 2;
            orb.style.left = left + 'px'; orb.style.top = top + 'px';
            return orb;
        }

        showSwapAnimation(idx1, idx2, callback) {
            this.animating = true;
            const board = document.getElementById('board');
            const orb1 = this.createOrb(document.getElementById('cell-' + idx1));
            const orb2 = this.createOrb(document.getElementById('cell-' + idx2));
            board.appendChild(orb1); board.appendChild(orb2);
            void orb1.offsetWidth; // Force reflow

            const r1 = orb1.style.left; const t1 = orb1.style.top;
            const r2 = orb2.style.left; const t2 = orb2.style.top;

            orb1.style.left = r2; orb1.style.top = t2;
            orb2.style.left = r1; orb2.style.top = t1;

            setTimeout(() => { orb1.remove(); orb2.remove(); this.animating = false; if (callback) callback(); }, 500);
        }

        showJetAnimation(fromIdx, toIdx, color='blue') {
            const board = document.getElementById('board');
            const cell1 = document.getElementById('cell-' + fromIdx);
            const cell2 = document.getElementById('cell-' + toIdx);
            if (!cell1 || !cell2) return;

            const r1 = cell1.getBoundingClientRect();
            const r2 = cell2.getBoundingClientRect();
            const boardR = board.getBoundingClientRect();

            const x1 = r1.left + r1.width/2 - boardR.left;
            const y1 = r1.top + r1.height/2 - boardR.top;
            const x2 = r2.left + r2.width/2 - boardR.left;
            const y2 = r2.top + r2.height/2 - boardR.top;
            const length = Math.hypot(x2-x1, y2-y1);
            const angle = Math.atan2(y2-y1, x2-x1) * 180 / Math.PI;

            const beam = document.createElement('div');
            beam.className = color === 'blue' ? 'jet-beam' : 'fire-beam';
            beam.style.width = length + 'px';
            beam.style.left = x1 + 'px';
            beam.style.top = y1 + 'px';
            beam.style.transform = `translateY(-50%) rotate(${angle}deg)`;

            board.appendChild(beam);
            requestAnimationFrame(() => {
                beam.style.opacity = 1;
                setTimeout(() => { beam.style.opacity = 0; setTimeout(() => { if(beam.parentNode) beam.remove(); }, 200); }, 300);
            });
        }
        
        showResurrectAnimation(idx, callback) {
            this.animating = true;
            const cell = document.getElementById('cell-' + idx);
            if (!cell) { this.animating = false; if(callback) callback(); return; }
            const soul = document.createElement('div');
            soul.className = 'resurrect-soul'; soul.innerText = 'ğŸ‘»';
            cell.appendChild(soul);
            setTimeout(() => { if(soul.parentNode) soul.remove(); this.animating = false; if(callback) callback(); }, 1200);
        }

        showExplosionAnimation(centerIdx, callback) {
            this.animating = true;
            const board = document.getElementById('board');
            const cell = document.getElementById('cell-' + centerIdx);
            const r = cell.getBoundingClientRect();
            const boardR = board.getBoundingClientRect();
            
            // Explosion covers 3x3 roughly
            const size = r.width * 3; 
            const exp = document.createElement('div');
            exp.className = 'explosion-effect';
            exp.style.width = size + 'px'; exp.style.height = size + 'px';
            exp.style.left = (r.left - boardR.left + r.width/2 - size/2) + 'px';
            exp.style.top = (r.top - boardR.top + r.height/2 - size/2) + 'px';
            
            board.appendChild(exp);
            Sound.explosion();
            
            setTimeout(() => { exp.remove(); this.animating = false; if(callback) callback(); }, 700);
        }

        // --- Executions ---

        executeJetSkill(idx) {
            const cells = document.getElementById('board').children;
            if(cells[idx].classList.contains('highlight-skill-target')) {
                Sound.jet();
                this.animating = true;
                this.showJetAnimation(this.selectedIdx, idx, 'blue');
                setTimeout(() => {
                    this.animating = false;
                    const victim = this.board[idx];
                    this.addToGraveyard(victim);
                    this.board[idx] = null;
                    this.board[this.selectedIdx].charge = 0;
                    this.render();
                    this.endTurn();
                }, 400); 
            } else {
                const p = this.board[idx];
                if (p && p.revealed && p.r === 7) { Sound.fail(); this.showMsg("BOSSå…ç–«æ°´æŸ±ï¼"); } else Sound.error();
            }
        }

        executeCannonSkill(centerIdx) {
            const cells = document.getElementById('board').children;
            if(!cells[centerIdx].classList.contains('highlight-cannon-target')) {
                Sound.error(); return;
            }

            // Check Condition: 3 pieces in 3x3
            const cx = centerIdx % 4;
            const cy = Math.floor(centerIdx / 4);
            const affectedIndices = [];
            let pieceCount = 0;

            for(let dy=-1; dy<=1; dy++) {
                for(let dx=-1; dx<=1; dx++) {
                    const nx=cx+dx, ny=cy+dy;
                    if(nx>=0 && nx<4 && ny>=0 && ny<8) {
                        const idx = ny*4+nx;
                        affectedIndices.push(idx);
                        if(this.board[idx] !== null) pieceCount++;
                    }
                }
            }

            if(pieceCount < 3) {
                Sound.fail();
                this.showMsg("ç›®æ¨™æ•¸é‡ä¸è¶³å®šä½å¤±æ•—");
                return;
            }

            // Fire!
            Sound.jet(); // Firing sound
            this.showJetAnimation(this.selectedIdx, centerIdx, 'orange');

            setTimeout(() => {
                this.showExplosionAnimation(centerIdx, () => {
                    // Logic: 
                    // 1. Revealed -> Destroy (All)
                    // 2. Hidden -> Reveal -> If Enemy Destroy, If Ally Keep
                    const attacker = this.board[this.selectedIdx];
                    
                    affectedIndices.forEach(idx => {
                        const p = this.board[idx];
                        if(!p) return;

                        let destroyed = false;
                        if(p.revealed) {
                            destroyed = true; // Destroy all revealed
                        } else {
                            p.revealed = true; // Reveal hidden
                            if(p.color !== attacker.color) {
                                destroyed = true; // Enemy -> Destroy
                            } else {
                                // Ally -> Keep (just revealed)
                            }
                        }

                        if(destroyed) {
                            this.addToGraveyard(p);
                            this.board[idx] = null;
                        }
                    });

                    attacker.charge = 0;
                    this.render();
                    this.endTurn();
                });
            }, 300);
        }

        executeMove(from, to) {
            const p = this.board[from];
            // Charge increment: Firefighter and Cannon
            if(p.isFF && p.charge < 3) p.charge++;
            if(p.r === 2 && this.mode === 'SPECIAL' && p.charge < 5) p.charge++;

            this.board[to] = p;
            this.board[from] = null;
            Sound.move();
            this.render();
            this.endTurn();
        }

        executeAttack(from, to, isDark) {
            const attacker = this.board[from];
            // Charge increment
            if(attacker.isFF && attacker.charge < 3) attacker.charge++;
            if(attacker.r === 2 && this.mode === 'SPECIAL' && attacker.charge < 5) attacker.charge++;

            if(isDark) {
                const target = this.board[to];
                target.revealed = true;
                this.render(); 
                if(target.color === attacker.color) {
                    Sound.fail(); this.showMsg("æ˜¯è‡ªå·±äºº"); setTimeout(() => this.endTurn(), 500); return;
                }
                let canKill = this.canPieceKill(attacker, target);
                if(canKill) setTimeout(() => this.performCapture(from, to), 500);
                else { Sound.fail(); this.shakePiece(from); this.showMsg("æ‰“ä¸é"); setTimeout(() => this.endTurn(), 500); }
            } else {
                this.performCapture(from, to);
            }
        }

        performCapture(from, to) {
            const victim = this.board[to];
            const killer = this.board[from];
            this.addToGraveyard(victim);
            Sound.capture();
            this.board[to] = killer;
            this.board[from] = null;
            this.render();
            this.startChainCapture(to);
        }

        startChainCapture(idx) {
            if(this.hasTargets(idx)) {
                this.isChainCapturing = true; this.chainIdx = idx; this.selectedIdx = idx;
                this.render(); this.highlightTargets(idx, true);
                document.getElementById('btn-end-capture').style.display = 'flex';
                this.showMsg("é€£åƒï¼");
            } else { setTimeout(() => this.endTurn(), 300); }
        }

        hasTargets(idx) {
            for(let i=0; i<32; i++) {
                if(i===idx) continue;
                const res = this.checkAttack(idx, i);
                if(res.reachable && (res.valid || res.isDark)) return true;
            }
            return false;
        }

        canPieceKill(attacker, target) {
            if(attacker.isFF) return target.r !== 7;
            if(target.isFF) return attacker.r === 7 || attacker.r === 2; // Marshal/General or Cannon kills FF
            if(attacker.r === 2) return true; 
            if(attacker.r === 7 && target.r === 1) return false; 
            if(attacker.r === 1 && target.r === 7) return true; 
            return attacker.r >= target.r;
        }

        checkAttack(from, to) {
            const attacker = this.board[from];
            const target = this.board[to];
            if(!target) return {reachable:false};
            const isDark = !target.revealed;
            const dist = this.getDist(from, to);
            let reachable = false;

            if(attacker.r === 2) { 
                const x1=from%4, y1=Math.floor(from/4);
                const x2=to%4, y2=Math.floor(to/4);
                if(x1===x2 || y1===y2) {
                    let screens = 0;
                    const minX=Math.min(x1,x2), maxX=Math.max(x1,x2);
                    const minY=Math.min(y1,y2), maxY=Math.max(y1,y2);
                    if(y1===y2) { for(let k=minX+1;k<maxX;k++) if(this.board[y1*4+k]) screens++; }
                    else { for(let k=minY+1;k<maxY;k++) if(this.board[k*4+x1]) screens++; }
                    if(screens === 1) reachable = true;
                }
            } else { if(dist === 1) reachable = true; }

            if(!reachable) return {reachable:false};
            if(isDark) return {reachable:true, valid:true, isDark:true};
            if(target.color === attacker.color) return {reachable:true, valid:false, isDark:false};
            return {reachable:true, valid:this.canPieceKill(attacker, target), isDark:false};
        }

        getDist(i1, i2) { return Math.abs((i1%4)-(i2%4)) + Math.abs(Math.floor(i1/4)-Math.floor(i2/4)); }
        isAdjacent(i1, i2) { return this.getDist(i1, i2) === 1; }
        shakePiece(idx) { const el = document.getElementById(`piece-${idx}`); if(el) { el.classList.remove('fail-shake'); void el.offsetWidth; el.classList.add('fail-shake'); } }

        addToGraveyard(p) {
            const div = document.createElement('div');
            div.className = `graveyard-piece ${p.color} ${p.isFF ? 'ff-dead' : ''}`;
            if (p.isFF) { div.innerText = p.color === 'red' ? 'ğŸ‘¨â€ğŸš’' : 'ğŸ¥·'; } 
            else { div.innerText = p.n; }
            if(p.color === 'red') document.getElementById('graveyard-red-strip').appendChild(div);
            else document.getElementById('graveyard-black-strip').appendChild(div);
        }

        highlightTargets(idx, isChain=false) {
            const cells = document.getElementById('board').children;
            for(let i=0; i<32; i++) {
                if(i===idx) continue;
                const p = this.board[i];
                if(!p) {
                    if(!isChain && this.isAdjacent(idx, i)) cells[i].classList.add('highlight-move');
                    continue;
                }
                const res = this.checkAttack(idx, i);
                if(res.reachable) {
                    if(res.isDark) cells[i].classList.add('highlight-dark-attack');
                    else if(res.valid) cells[i].classList.add('highlight-capture');
                }
            }
        }

        resetControls() {
            document.getElementById('btn-skill-jet').style.display = 'none';
            document.getElementById('btn-skill-cannon').style.display = 'none';
            document.getElementById('btn-pawn-swap').style.display = 'none';
            document.getElementById('btn-pawn-rez').style.display = 'none';
            document.getElementById('btn-pawn-equip').style.display = 'none';
            document.getElementById('btn-cancel').style.display = 'none';
            document.getElementById('btn-end-capture').style.display = 'none';
        }

        cancelAction() {
            this.selectedIdx = -1;
            this.skillMode = null;
            this.resetControls();
            this.render();
        }

        endTurn() {
            this.selectedIdx = -1;
            this.isChainCapturing = false;
            this.chainIdx = -1;
            this.skillMode = null;
            this.turn = (this.turn === 'red') ? 'black' : 'red';
            this.updateUI();
            this.resetControls();
            this.render();
            this.checkWin();
        }

        updateUI(msg) {
            const disp = document.getElementById('turn-display');
            disp.innerText = msg || (this.turn === 'red' ? 'ç´…æ–¹å›åˆ' : 'é»‘æ–¹å›åˆ');
            disp.className = 'turn-indicator';
            if(this.turn === 'red') disp.classList.add('active-red');
            if(this.turn === 'black') disp.classList.add('active-black');
        }

        showMsg(txt) {
            const el = document.getElementById('message-overlay');
            el.innerText = txt; el.style.opacity = 1;
            setTimeout(()=>el.style.opacity=0, 1000);
        }

        checkWin() {
            let r=0, b=0;
            this.board.forEach(p => { if(p) p.color==='red' ? r++ : b++; });
            if(r===0 || b===0) {
                this.gameOver = true;
                document.getElementById('winner-title').innerText = r===0 ? "é»‘æ–¹ç²å‹ï¼" : "ç´…æ–¹ç²å‹ï¼";
                document.getElementById('game-over-screen').classList.remove('hidden-screen');
                Sound.win();
            }
        }
    }

    const game = new DarkChess();
</script>
</body>
</html>

