<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ÊöóÊ£ã - Ê∂àÈò≤Ê†ìÂ§ßÂì• (Âæ©Ê¥ªÂãïÁï´Áâà)</title>
    <style>
        :root {
            --board-bg: #e6cca0;
            --grid-line: #5c4033;
            --piece-red: #c0392b;
            --piece-black: #2c3e50;
            --valid-capture: rgba(231, 76, 60, 0.6);
            --valid-skill: rgba(52, 152, 219, 0.6);
            --valid-dark-attack: rgba(230, 126, 34, 0.6);
            --ui-bg: #2c3e50;
            --panel-bg: rgba(0, 0, 0, 0.3);
            /* Handle safe area for iPhone X+ */
            --safe-bottom: env(safe-area-inset-bottom, 20px);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, "bikai", "KaiTi", "DFKai-SB", serif;
            background-color: var(--ui-bg);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            /* Use dynamic viewport height to avoid browser bar issues */
            height: 100vh;
            height: 100dvh; 
            overflow: hidden;
            color: white;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
        }

        /* --- Screens --- */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(44, 62, 80, 0.98);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 1000; transition: opacity 0.3s;
        }
        .hidden-screen { display: none !important; opacity: 0; pointer-events: none; }

        h1 { font-size: 2rem; margin-bottom: 1.5rem; color: #f1c40f; text-shadow: 2px 2px 0 #000; text-align: center; }
        
        .menu-btn {
            padding: 15px 0; width: 80%; max-width: 300px;
            font-size: 1.2rem; margin: 10px 0; border: none; border-radius: 50px;
            background: #e74c3c; color: white; cursor: pointer; box-shadow: 0 5px 0 #c0392b;
            font-family: inherit; font-weight: bold;
        }
        .menu-btn:active { transform: translateY(5px); box-shadow: none; }
        .btn-blue { background: #3498db; box-shadow: 0 5px 0 #2980b9; }
        .btn-green { background: #2ecc71; box-shadow: 0 5px 0 #27ae60; }

        /* --- Game Layout (Flexbox Column) --- */
        #game-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
            max-width: 600px; /* Limit width on tablets */
            margin: 0 auto;
            /* Remove padding that causes overflow */
            padding: 5px 0 0 0;
            box-sizing: border-box;
        }

        /* 1. Top Panel (Fixed height content) */
        .top-panel {
            flex: 0 0 auto; /* Don't grow or shrink */
            display: flex;
            flex-direction: column;
            width: 100%;
            padding: 0 10px;
            box-sizing: border-box;
            gap: 5px;
            z-index: 10;
        }

        #status-bar {
            width: 100%;
            display: flex;
            justify-content: center;
            padding: 2px 0;
        }

        .turn-indicator {
            padding: 5px 20px; border-radius: 20px; background: #444; color: #ccc;
            border: 2px solid transparent; min-width: 100px; text-align: center;
            font-size: 1rem; font-weight: bold; box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        .turn-indicator.active-red { background: var(--piece-red); color: white; border-color: #e74c3c; box-shadow: 0 0 10px var(--piece-red); }
        .turn-indicator.active-black { background: black; color: white; border-color: #7f8c8d; box-shadow: 0 0 10px white; }

        .graveyard-strip {
            width: 100%;
            height: 40px; /* Fixed height for consistency */
            background: var(--panel-bg);
            border: 1px solid #5c4033;
            border-radius: 8px;
            display: flex;
            align-items: center;
            padding: 0 5px;
            overflow-x: auto;
            white-space: nowrap;
            gap: 5px;
            box-sizing: border-box;
        }
        /* Custom Scrollbar for graveyard */
        .graveyard-strip::-webkit-scrollbar { height: 0px; }

        .graveyard-piece {
            width: 28px; height: 28px; border-radius: 50%;
            background-color: #f3e5ab; color: #000;
            display: flex; justify-content: center; align-items: center;
            font-size: 16px; font-weight: bold; border: 2px solid #8b4513;
            flex-shrink: 0; position: relative;
        }
        .graveyard-piece.red { color: var(--piece-red); border-color: var(--piece-red); }
        .graveyard-piece.black { color: var(--piece-black); border-color: var(--piece-black); }
        .graveyard-piece.ff-dead { border: 3px double; font-size: 18px; }
        .graveyard-piece.ff-dead::after { content: 'üíÄ'; position: absolute; font-size: 10px; bottom: -4px; right: -4px; }

        /* 2. Board Wrapper (Flexible space) */
        .board-wrapper {
            flex: 1 1 auto; /* Take all remaining vertical space */
            min-height: 0; /* Crucial: allows flex item to shrink below content size */
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            padding: 5px;
            box-sizing: border-box;
            overflow: hidden;
        }

        #board {
            /* The board tries to fill the wrapper but keeps aspect ratio */
            height: 100%; 
            width: auto;
            max-width: 100%;
            aspect-ratio: 4/8; /* Enforce 1:2 ratio */
            
            background-color: var(--board-bg);
            border: 4px solid #5c4033; border-radius: 8px;
            display: grid; grid-template-columns: repeat(4, 1fr); grid-template-rows: repeat(8, 1fr);
            gap: 1px; box-shadow: 0 5px 15px rgba(0,0,0,0.6);
            position: relative;
        }

        .cell {
            position: relative; border: 1px solid rgba(92, 64, 51, 0.2);
            display: flex; justify-content: center; align-items: center; cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .piece {
            width: 90%; height: 90%; border-radius: 50%;
            background: #f3e5ab; border: 2px solid #8b4513;
            box-shadow: inset 2px 2px 5px rgba(255,255,255,0.4), 1px 1px 3px rgba(0,0,0,0.4);
            display: flex; justify-content: center; align-items: center;
            font-size: 1.6rem; /* Dynamic font size adjustment via JS preferred but css clamp works too */
            font-size: clamp(1rem, 4vh, 2rem);
            font-weight: bold; user-select: none;
            position: absolute; z-index: 10;
            transition: transform 0.2s, top 0.2s, left 0.2s;
        }
        .piece.hidden {
            background: radial-gradient(circle, #8b4513 30%, #5c4033 100%);
            color: transparent; border-color: #3e2723;
        }
        .piece.hidden::after { content: "‚ú¶"; color: rgba(255,255,255,0.15); font-size: 1.2rem; }
        .piece.red { color: var(--piece-red); }
        .piece.black { color: var(--piece-black); }
        
        .piece.selected { 
            transform: scale(1.15); z-index: 20; 
            box-shadow: 0 0 0 3px #f1c40f, 0 0 10px #f1c40f; 
        }

        .piece.firefighter {
            border-width: 3px; display: flex; flex-direction: column; justify-content: center; align-items: center;
            line-height: 1;
        }
        .piece.firefighter.red { background-color: #fff0f0; border-color: #c0392b; color: #c0392b; }
        .piece.firefighter.red::before { content: 'üî•'; font-size: 0.7rem; position: absolute; top: 1px; right: 1px; }
        .piece.firefighter.black { background-color: #dcdde1; border-color: #2c3e50; border-style: double; color: #2c3e50; }
        .piece.firefighter.black::before { content: 'üíß'; font-size: 0.7rem; position: absolute; top: 1px; left: 1px; }
        
        .charge-bar { position: absolute; bottom: 5%; display: flex; gap: 2px; height: 6px; align-items: center; }
        .charge-pip { width: 6px; height: 6px; border-radius: 50%; background: #ccc; border: 1px solid #777; }
        .charge-pip.on { background: #3498db; border-color: #2980b9; box-shadow: 0 0 3px #3498db; }

        /* --- Animations --- */
        .jet-beam {
            position: absolute;
            height: 12px; /* Thickness of the beam */
            background: linear-gradient(90deg, rgba(52, 152, 219, 0.9), rgba(133, 193, 233, 0.5) 80%, rgba(255,255,255,0));
            box-shadow: 0 0 10px #3498db, 0 0 20px #2980b9;
            border-radius: 6px;
            z-index: 999;
            transform-origin: left center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
        }

        .teleport-orb {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.9) 10%, rgba(155, 89, 182, 0.8) 60%, rgba(142, 68, 173, 0) 70%);
            box-shadow: 0 0 15px rgba(155, 89, 182, 0.8), 0 0 30px rgba(142, 68, 173, 0.4);
            z-index: 998;
            pointer-events: none;
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            mix-blend-mode: screen;
        }

        .resurrect-soul {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            font-size: 2rem;
            z-index: 1000;
            pointer-events: none;
            animation: riseFade 1.2s forwards ease-in-out;
            text-shadow: 0 0 10px #9b59b6, 0 0 20px #8e44ad;
        }
        
        @keyframes riseFade {
            0% { transform: translateY(0) scale(0.5); opacity: 0; }
            20% { opacity: 1; transform: translateY(-10px) scale(1.2); }
            80% { opacity: 0.8; }
            100% { transform: translateY(-60px) scale(1.5); opacity: 0; }
        }

        .highlight-move::before { content: ''; position: absolute; width: 20%; height: 20%; background: #2ecc71; border-radius: 50%; opacity: 0.8; }
        .highlight-capture { background-color: var(--valid-capture); box-shadow: inset 0 0 10px #c0392b; }
        .highlight-dark-attack { background-color: var(--valid-dark-attack); box-shadow: inset 0 0 10px #d35400; }
        .highlight-skill-target { background-color: rgba(52, 152, 219, 0.6); box-shadow: inset 0 0 15px #3498db; cursor: crosshair; animation: pulse-blue 1s infinite; }
        @keyframes pulse-blue { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }
        .fail-shake { animation: shake 0.4s; }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }

        /* 3. Bottom Panel & Controls (In Flow) */
        #bottom-graveyard-container {
            flex: 0 0 auto;
            margin-bottom: 5px;
        }

        #controls-area {
            flex: 0 0 auto; /* Don't grow/shrink */
            position: relative; /* Changed from fixed to relative to be part of the flow */
            width: 100%;
            background: rgba(30, 30, 30, 0.8);
            backdrop-filter: blur(5px);
            border-top: 1px solid #555;
            padding: 8px;
            padding-bottom: calc(8px + var(--safe-bottom)); /* Safe area for iPhone */
            box-sizing: border-box;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
            z-index: 100;
            min-height: 60px;
        }

        .action-btn {
            padding: 10px 15px;
            font-size: 0.95rem;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            color: white;
            display: none;
            box-shadow: 0 3px 0 rgba(0,0,0,0.3);
            align-items: center;
            justify-content: center;
            font-weight: bold;
            flex-grow: 1;
            max-width: 48%; /* Fit 2 in a row easily */
        }
        .action-btn:active { transform: translateY(3px); box-shadow: none; }
        
        #btn-skill-jet { background: #3498db; }
        #btn-skill-jet.disabled { background: #7f8c8d; opacity: 0.6; pointer-events: none; }
        #btn-pawn-swap { background: #9b59b6; }
        #btn-pawn-rez { background: #f1c40f; color: #333; }
        #btn-pawn-equip { background: #27ae60; }
        #btn-cancel { background: #e74c3c; max-width: 30%; }
        #btn-end-capture { background: #e67e22; }
        #btn-reset { background: #95a5a6; max-width: 20%; font-size: 0.9rem; padding: 5px; }

        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 2000;
            display: flex; justify-content: center; align-items: center;
            padding: 20px; box-sizing: border-box;
        }
        .modal-content {
            background: #fff; color: #333; padding: 20px; border-radius: 15px;
            text-align: center; width: 100%; max-width: 350px; border: 5px solid #f1c40f;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
        }
        .modal-btns { display: flex; gap: 10px; justify-content: center; margin-top: 20px; }
        
        #message-overlay {
            position: fixed; top: 40%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9); color: #f1c40f; padding: 15px 30px; border-radius: 50px;
            font-size: 1.5rem; pointer-events: none; opacity: 0; transition: opacity 0.3s; z-index: 1500;
            white-space: nowrap; border: 2px solid #f1c40f;
        }

        /* Desktop specific overrides */
        @media (min-width: 768px) {
            #game-container {
                flex-direction: row;
                align-items: center;
                justify-content: center;
                max-width: 1000px;
                padding: 20px;
            }
            .top-panel { width: 15%; height: 80%; justify-content: flex-start; }
            #status-bar { margin-bottom: 20px; }
            .graveyard-strip {
                width: 100%; height: auto; flex: 1; flex-direction: column; overflow-x: hidden; overflow-y: auto; padding: 10px 0;
            }
            .board-wrapper { width: 60%; height: 90vh; }
            #board { height: 100%; max-height: 800px; width: auto; aspect-ratio: 4/8; }
            .piece { font-size: 2.5rem; }
            #bottom-graveyard-container { order: 3; width: 15%; height: 80%; margin-bottom: 0; }
            #controls-area {
                position: absolute; bottom: 20px; width: auto; background: transparent; border: none; box-shadow: none;
            }
            .action-btn { max-width: 200px; }
        }
    </style>
</head>
<body>

<!-- Start Screen -->
<div id="start-screen" class="screen">
    <h1>ÊöóÊ£ãÂ∞çÊ±∫</h1>
    <button class="menu-btn" onclick="game.startGame('STANDARD')">Á∂ìÂÖ∏ÈÄ£ÂêÉÁâà</button>
    <button class="menu-btn btn-blue" onclick="game.startGame('SPECIAL')">ÁâπÊÆäÊ®°ÂºèÔºöÊ∂àÈò≤Ê†ìÂ§ßÂì•</button>
</div>

<!-- Game Over -->
<div id="game-over-screen" class="screen hidden-screen">
    <h1 id="winner-title">ÈÅäÊà≤ÁµêÊùü</h1>
    <button class="menu-btn btn-green" onclick="game.resetToMenu()">ÈáçÊñ∞ÈÅäÁé©</button>
</div>

<!-- Promotion Modal -->
<div id="promotion-modal" class="modal-overlay hidden-screen">
    <div class="modal-content">
        <h2 style="margin:0 0 10px 0;">üöí ÁôºÁèæË£ùÂÇôÔºÅ</h2>
        <p style="font-size:1.1rem;">ÊòØÂê¶ËÆìÈÄôÂêçÂ∞èÂÖµÁ©ø‰∏äÊ∂àÈò≤Ë£ùÂÇôÔºü</p>
        <div style="background:#eee; padding:10px; border-radius:8px; margin:10px 0; font-size:0.9rem; text-align:left;">
            <strong>ËÉΩÂäõÔºö</strong>ÊØîÂ∞áÂ∞è„ÄÅÊØîÂ£´Â§ß<br>
            <strong>ÊäÄËÉΩÔºö</strong><br>
            üåä Ê∞¥Êü±Âô¥Â∞Ñ (ÈõÜÊªø3Ê∞£„ÄÅÂ∞áÂ∏•ÂÖçÁñ´)<br>
            üîÑ Âø´ÈÄüÊèõ‰Ωç (ËàáÂ∞èÂÖµ‰∫§Êèõ)<br>
            ‚ö∞Ô∏è ÁäßÁâ≤Âæ©Ê¥ª (Ê∂àËÄóÂ∞èÂÖµ)
        </div>
        <div class="modal-btns">
            <button class="action-btn btn-green" style="display:flex; background:#2ecc71;" onclick="game.confirmPromotion(true)">‚úÖ Á©øË£ùÂÇô</button>
            <button class="action-btn" style="display:flex; background:#95a5a6;" onclick="game.confirmPromotion(false)">‚ùå ‰øùÊåÅÂéüÁãÄ</button>
        </div>
    </div>
</div>

<div id="game-container">
    <div class="top-panel" id="top-panel">
        <div id="status-bar">
            <div id="turn-display" class="turn-indicator">Ê∫ñÂÇôÈñãÂßã</div>
        </div>
        <div class="graveyard-strip" id="graveyard-red-strip"></div>
    </div>

    <div class="board-wrapper">
        <div id="board"></div>
    </div>

    <div class="top-panel" id="bottom-graveyard-container">
        <div class="graveyard-strip" id="graveyard-black-strip"></div>
    </div>

    <div id="controls-area">
        <button id="btn-skill-jet" class="action-btn" onclick="game.activateSkill('JET')">üåä Ê∞¥Êü±Âô¥Â∞Ñ</button>
        <button id="btn-pawn-swap" class="action-btn" onclick="game.pawnAction('SWAP')">üîÑ ËàáÂ§ßÂì•Êèõ‰Ωç</button>
        <button id="btn-pawn-rez" class="action-btn" onclick="game.pawnAction('RESURRECT')">‚ö∞Ô∏è ÁäßÁâ≤Âè¨Âñö</button>
        <button id="btn-pawn-equip" class="action-btn" onclick="game.pawnAction('EQUIP')">üõ†Ô∏è Ë£ùÂÇôÊ∂àÈò≤Ê†ì</button>
        
        <button id="btn-end-capture" class="action-btn" onclick="game.endTurn()">‚èπ ÂÅúÊ≠¢ÈÄ£ÂêÉ</button>
        <button id="btn-cancel" class="action-btn" onclick="game.cancelAction()">‚ùå ÂèñÊ∂à</button>
        <button id="btn-reset" class="action-btn" style="display:flex;" onclick="game.resetToMenu()">‚ü≤</button>
    </div>
</div>

<div id="message-overlay"></div>

<script>
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const Sound = {
        play: (freq, type, dur) => {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + dur);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + dur);
        },
        flip: () => Sound.play(600, 'square', 0.08),
        move: () => Sound.play(150, 'triangle', 0.1),
        capture: () => {
             if(audioCtx.state === 'suspended') audioCtx.resume();
             const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
             osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, audioCtx.currentTime); 
             osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime+0.2);
             gain.gain.setValueAtTime(0.2, audioCtx.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime+0.2);
             osc.connect(gain); gain.connect(audioCtx.destination); osc.start(); osc.stop(audioCtx.currentTime+0.2);
        },
        error: () => Sound.play(80, 'sawtooth', 0.2),
        fail: () => { Sound.play(150, 'sawtooth', 0.1); setTimeout(()=>Sound.play(100, 'sawtooth', 0.1), 100); },
        skill: () => { [400, 600, 800].forEach((f,i) => setTimeout(()=>Sound.play(f,'sine',0.2), i*100)); },
        jet: () => {
             if(audioCtx.state === 'suspended') audioCtx.resume();
             const bufferSize = audioCtx.sampleRate * 0.5;
             const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
             const data = buffer.getChannelData(0);
             for(let i=0; i<bufferSize; i++) data[i] = Math.random() * 2 - 1;
             const noise = audioCtx.createBufferSource(); noise.buffer = buffer;
             const gain = audioCtx.createGain(); gain.gain.setValueAtTime(0.3, audioCtx.currentTime); 
             gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime+0.5);
             noise.connect(gain); gain.connect(audioCtx.destination); noise.start();
        },
        teleport: () => {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(200, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.5);
            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + 0.5);
        },
        win: () => { [300, 400, 500, 600].forEach((f,i) => setTimeout(()=>Sound.play(f,'sine',0.3), i*150)); }
    };

    const PIECES = {
        RED: [
            {id:'r7',n:'Â∏•',r:7,c:1},{id:'r6',n:'‰ªï',r:6,c:2},{id:'r5',n:'Áõ∏',r:5,c:2},
            {id:'r4',n:'‰ø•',r:4,c:2},{id:'r3',n:'ÂÇå',r:3,c:2},{id:'r2',n:'ÁÇÆ',r:2,c:2},
            {id:'r1',n:'ÂÖµ',r:1,c:5}
        ],
        BLACK: [
            {id:'b7',n:'Â∞á',r:7,c:1},{id:'b6',n:'Â£´',r:6,c:2},{id:'b5',n:'Ë±°',r:5,c:2},
            {id:'b4',n:'Ëªä',r:4,c:2},{id:'b3',n:'È¶¨',r:3,c:2},{id:'b2',n:'ÂåÖ',r:2,c:2},
            {id:'b1',n:'Âçí',r:1,c:5}
        ]
    };

    class DarkChess {
        constructor() {
            this.board = [];
            this.turn = null; 
            this.myColor = null; 
            this.selectedIdx = -1;
            this.mode = 'STANDARD';
            this.gameOver = false;
            this.isChainCapturing = false;
            this.chainIdx = -1;
            this.pendingPromoIdx = -1;
            this.pendingPromoCtx = false; // Is first move context?
            this.isFirstMove = true;
            this.skillMode = null;
            this.animating = false; // Block inputs during animations
        }

        startGame(mode) {
            this.mode = mode;
            document.getElementById('start-screen').classList.add('hidden-screen');
            this.init();
        }

        init() {
            let pool = [];
            PIECES.RED.forEach(p => { for(let i=0; i<p.c; i++) pool.push({...p, color:'red', revealed:false, isFF:false, charge:0}); });
            PIECES.BLACK.forEach(p => { for(let i=0; i<p.c; i++) pool.push({...p, color:'black', revealed:false, isFF:false, charge:0}); });
            
            for(let i=pool.length-1; i>0; i--){
                const j = Math.floor(Math.random()*(i+1));
                [pool[i], pool[j]] = [pool[j], pool[i]];
            }

            this.board = pool;
            this.turn = null;
            this.myColor = null;
            this.selectedIdx = -1;
            this.isChainCapturing = false;
            this.chainIdx = -1;
            this.isFirstMove = true;
            this.gameOver = false;
            this.skillMode = null;
            this.animating = false;
            
            document.getElementById('graveyard-red-strip').innerHTML = '';
            document.getElementById('graveyard-black-strip').innerHTML = '';
            
            this.render();
            this.updateUI("Ë´ãÁøªÁâåÊ±∫ÂÆöÂÖàÂæåÊâã");
            this.resetControls();
        }

        resetToMenu() {
            this.gameOver = false;
            document.getElementById('game-over-screen').classList.add('hidden-screen');
            document.getElementById('promotion-modal').classList.add('hidden-screen');
            document.getElementById('message-overlay').style.opacity = 0;
            document.getElementById('start-screen').classList.remove('hidden-screen');
            // Visual cleanup
            document.getElementById('board').innerHTML = '';
            document.getElementById('graveyard-red-strip').innerHTML = '';
            document.getElementById('graveyard-black-strip').innerHTML = '';
        }

        render() {
            const boardEl = document.getElementById('board');
            // Check for existing animations before clearing to avoid glitches, though logic usually prevents this
            // Here we simply rebuild to keep state consistent.
            boardEl.innerHTML = '';
            this.board.forEach((p, idx) => {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.id = `cell-${idx}`;
                cell.onclick = () => this.handleCellClick(idx);
                
                if(p) {
                    const el = document.createElement('div');
                    el.className = `piece ${p.color} ${p.revealed ? '':'hidden'} ${p.isFF ? 'firefighter':''}`;
                    el.id = `piece-${idx}`;
                    
                    if(p.revealed) {
                        if (p.isFF) {
                            el.innerText = p.color === 'red' ? 'üë®‚Äçüöí' : 'ü•∑'; 
                        } else {
                            el.innerText = p.n;
                        }

                        if(p.isFF) {
                            const bar = document.createElement('div');
                            bar.className = 'charge-bar';
                            for(let i=0; i<3; i++) {
                                const pip = document.createElement('div');
                                pip.className = `charge-pip ${i < p.charge ? 'on':''}`;
                                bar.appendChild(pip);
                            }
                            el.appendChild(bar);
                        }
                    }
                    if(this.selectedIdx === idx) el.classList.add('selected');
                    cell.appendChild(el);
                }
                boardEl.appendChild(cell);
            });
        }

        handleCellClick(idx) {
            if(this.gameOver || this.animating) return;
            const p = this.board[idx];

            if(this.skillMode === 'JET') {
                this.executeJetSkill(idx);
                return;
            }

            if(this.isChainCapturing) {
                if(idx === this.chainIdx) return;
                if(p) {
                    const res = this.checkAttack(this.chainIdx, idx);
                    if(res.valid || res.isDark) {
                        this.executeAttack(this.chainIdx, idx, res.isDark);
                    } else {
                        Sound.error();
                        this.showMsg("ÁÑ°Ê≥ïÊîªÊìä");
                    }
                } else {
                    Sound.error();
                    this.showMsg("‰∏çÂèØËµ∞Á©∫Âú∞");
                }
                return;
            }

            // A. First Flip
            if(this.turn === null) {
                if(p && !p.revealed) this.performFirstFlip(idx);
                return;
            }

            // B. Selection
            if(p && p.revealed && p.color === this.turn) {
                this.selectPiece(idx);
                return;
            }

            // C. Action
            if(this.selectedIdx !== -1) {
                if(idx === this.selectedIdx) { this.cancelAction(); return; }
                
                if(!p) {
                    if(this.isAdjacent(this.selectedIdx, idx)) {
                        this.executeMove(this.selectedIdx, idx);
                    } else {
                        this.cancelAction();
                        Sound.error();
                    }
                    return;
                }

                const res = this.checkAttack(this.selectedIdx, idx);
                if(res.reachable) {
                    if(res.valid || res.isDark) {
                        this.executeAttack(this.selectedIdx, idx, res.isDark);
                    } else {
                        Sound.error();
                        this.shakePiece(this.selectedIdx);
                        this.showMsg("Êâì‰∏çÈÅéÔºÅ");
                    }
                } else {
                    this.cancelAction();
                }
                return;
            }

            // D. Normal Flip
            if(p && !p.revealed) {
                this.performNormalFlip(idx);
            }
        }

        performFirstFlip(idx) {
            const p = this.board[idx];
            p.revealed = true;
            this.myColor = p.color;
            Sound.flip();
            this.render();

            if(this.mode === 'SPECIAL' && p.r === 1 && !this.hasFirefighterOnBoard(p.color)) {
                this.triggerPromotion(idx, true); 
            } else {
                this.turn = (p.color === 'red') ? 'black' : 'red';
                this.isFirstMove = true; 
                this.updateUI();
            }
        }

        performNormalFlip(idx) {
            const p = this.board[idx];
            p.revealed = true;
            Sound.flip();
            this.render();

            if(this.mode === 'SPECIAL' && p.r === 1 && p.color === this.turn && !this.hasFirefighterOnBoard(p.color)) {
                this.triggerPromotion(idx, false);
            } else {
                this.isFirstMove = false;
                this.endTurn();
            }
        }

        triggerPromotion(idx, isFirstMoveCtx) {
            this.pendingPromoIdx = idx;
            this.pendingPromoCtx = isFirstMoveCtx;
            document.getElementById('promotion-modal').classList.remove('hidden-screen');
        }

        confirmPromotion(yes) {
            document.getElementById('promotion-modal').classList.add('hidden-screen');
            
            if (this.pendingPromoIdx === -1 || !this.board[this.pendingPromoIdx]) {
                if (this.turn === null) this.init(); 
                return;
            }

            const p = this.board[this.pendingPromoIdx];
            
            if(yes) {
                p.isFF = true; p.r = 6.5; p.n = 'Ê∂àÈò≤Ê†ì';
                Sound.skill();
                this.showMsg("Ê∂àÈò≤Ê†ìÁôªÂ†¥ÔºÅ");
            }

            if (this.pendingPromoCtx) {
                this.turn = (p.color === 'red') ? 'black' : 'red';
                this.isFirstMove = true;
                this.updateUI();
                this.render();
            } else {
                this.isFirstMove = false;
                this.endTurn();
            }
            
            this.pendingPromoIdx = -1;
        }

        hasFirefighterOnBoard(color) {
            return this.board.some(p => p && p.color === color && p.isFF);
        }

        hasFirefighterInGraveyard(color) {
            const graveId = color === 'red' ? 'graveyard-red-strip' : 'graveyard-black-strip';
            const grave = document.getElementById(graveId);
            return grave.innerHTML.includes('ff-dead');
        }

        selectPiece(idx) {
            this.cancelAction();
            this.selectedIdx = idx;
            const p = this.board[idx];
            Sound.flip();
            this.render();
            this.highlightTargets(idx);

            if(this.mode === 'SPECIAL') {
                const jetBtn = document.getElementById('btn-skill-jet');
                const swapBtn = document.getElementById('btn-pawn-swap');
                const rezBtn = document.getElementById('btn-pawn-rez');
                const equipBtn = document.getElementById('btn-pawn-equip');
                const cancelBtn = document.getElementById('btn-cancel');

                if(p.isFF) {
                    jetBtn.style.display = 'flex'; 
                    if (p.charge < 3) {
                        jetBtn.classList.add('disabled');
                        jetBtn.innerText = `ÈõÜÊ∞£‰∏≠ (${p.charge}/3)`;
                    } else {
                        jetBtn.classList.remove('disabled');
                        jetBtn.innerText = `üåä Ê∞¥Êü±Âô¥Â∞Ñ (READY)`;
                    }
                    cancelBtn.style.display = 'flex';
                } 
                else if (p.r === 1) { // Pawn
                    const hasFF = this.hasFirefighterOnBoard(p.color);
                    const hasDeadFF = this.hasFirefighterInGraveyard(p.color);

                    if (!hasFF && !hasDeadFF) {
                        equipBtn.style.display = 'flex';
                    }

                    if(hasFF) {
                        swapBtn.style.display = 'flex';
                    }
                    if(hasDeadFF) {
                        rezBtn.style.display = 'flex';
                    }
                    cancelBtn.style.display = 'flex';
                }
            }
        }

        activateSkill(type) {
            if (type === 'JET') {
                this.skillMode = 'JET';
                this.highlightJetTargets();
                document.getElementById('btn-skill-jet').style.display = 'none';
            }
        }

        pawnAction(type) {
            const pawnIdx = this.selectedIdx;
            const pawn = this.board[pawnIdx];
            
            if (type === 'SWAP') {
                const ffIdx = this.board.findIndex(p => p && p.color === pawn.color && p.isFF);
                if (ffIdx !== -1) {
                    // Trigger Swap Animation
                    Sound.teleport();
                    this.showSwapAnimation(pawnIdx, ffIdx, () => {
                        this.board[pawnIdx] = this.board[ffIdx];
                        this.board[ffIdx] = pawn;
                        this.render();
                        this.endTurn();
                    });
                }
            } 
            else if (type === 'RESURRECT') {
                // Play animation first
                Sound.skill();
                this.showResurrectAnimation(pawnIdx, () => {
                    this.addToGraveyard(pawn);
                    const graveId = pawn.color === 'red' ? 'graveyard-red-strip' : 'graveyard-black-strip';
                    const grave = document.getElementById(graveId);
                    const ffEl = grave.querySelector('.ff-dead');
                    if(ffEl) ffEl.remove();

                    const newFF = { id: 'ff-'+Date.now(), color: pawn.color, revealed: true, isFF: true, r: 6.5, n: 'Ê∂àÈò≤Ê†ì', charge: 0 };
                    this.board[pawnIdx] = newFF;
                    this.render();
                    this.endTurn();
                });
            }
            else if (type === 'EQUIP') {
                pawn.isFF = true;
                pawn.r = 6.5; 
                pawn.n = 'Ê∂àÈò≤Ê†ì';
                Sound.skill();
                this.showMsg("Ë£ùÂÇôÂÆåÊàêÔºÅ");
                this.render();
                this.endTurn();
            }
        }

        highlightJetTargets() {
            const cells = document.getElementById('board').children;
            const origin = this.selectedIdx;
            const ox=origin%4, oy=Math.floor(origin/4);
            const dirs = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
            this.showMsg("ÈÅ∏ÊìáÂ∞ÑÊìäÁõÆÊ®ô (Â∞áÂ∏•ÂÖçÁñ´)");
            dirs.forEach(d => {
                let cx=ox+d[0], cy=oy+d[1];
                while(cx>=0 && cx<4 && cy>=0 && cy<8) {
                    const idx = cy*4+cx;
                    const p = this.board[idx];
                    if(p) {
                        if(p.revealed && p.color !== this.turn && p.r !== 7) {
                            cells[idx].classList.add('highlight-skill-target');
                        }
                        break; 
                    }
                    cx+=d[0]; cy+=d[1];
                }
            });
        }

        // --- Animations ---

        createOrb(cell) {
            const r = cell.getBoundingClientRect();
            const boardR = document.getElementById('board').getBoundingClientRect();
            
            // Calculate size dynamically based on cell size (80% of cell)
            const orbSize = r.width * 0.8;
            
            const orb = document.createElement('div');
            orb.className = 'teleport-orb';
            orb.style.width = orbSize + 'px';
            orb.style.height = orbSize + 'px';
            
            // Calculate exact center position relative to board
            // (Cell X relative to board) + (centering offset)
            const left = (r.left - boardR.left) + (r.width - orbSize) / 2;
            const top = (r.top - boardR.top) + (r.height - orbSize) / 2;
            
            orb.style.left = left + 'px';
            orb.style.top = top + 'px';
            
            return orb;
        }

        showSwapAnimation(idx1, idx2, callback) {
            this.animating = true;
            const board = document.getElementById('board');
            const cell1 = document.getElementById('cell-' + idx1);
            const cell2 = document.getElementById('cell-' + idx2);

            const orb1 = this.createOrb(cell1);
            const orb2 = this.createOrb(cell2);

            board.appendChild(orb1);
            board.appendChild(orb2);

            // Force reflow
            void orb1.offsetWidth;

            // Get target positions using the same logic as creation
            const r1 = cell1.getBoundingClientRect();
            const r2 = cell2.getBoundingClientRect();
            const boardR = board.getBoundingClientRect();
            const orbSize = r1.width * 0.8; // Assume grid cells are uniform

            const x1 = (r1.left - boardR.left) + (r1.width - orbSize) / 2;
            const y1 = (r1.top - boardR.top) + (r1.height - orbSize) / 2;
            
            const x2 = (r2.left - boardR.left) + (r2.width - orbSize) / 2;
            const y2 = (r2.top - boardR.top) + (r2.height - orbSize) / 2;

            // Swap destinations
            orb1.style.left = x2 + 'px';
            orb1.style.top = y2 + 'px';
            orb2.style.left = x1 + 'px';
            orb2.style.top = y1 + 'px';

            setTimeout(() => {
                orb1.remove();
                orb2.remove();
                this.animating = false;
                if (callback) callback();
            }, 500); // Matches CSS transition duration
        }

        showJetAnimation(fromIdx, toIdx) {
            this.animating = true;
            const board = document.getElementById('board');
            const cell1 = document.getElementById('cell-' + fromIdx);
            const cell2 = document.getElementById('cell-' + toIdx);

            if (!cell1 || !cell2) return;

            const r1 = cell1.getBoundingClientRect();
            const r2 = cell2.getBoundingClientRect();
            const boardR = board.getBoundingClientRect();

            const x1 = r1.left + r1.width/2 - boardR.left;
            const y1 = r1.top + r1.height/2 - boardR.top;
            const x2 = r2.left + r2.width/2 - boardR.left;
            const y2 = r2.top + r2.height/2 - boardR.top;

            const length = Math.hypot(x2-x1, y2-y1);
            const angle = Math.atan2(y2-y1, x2-x1) * 180 / Math.PI;

            const beam = document.createElement('div');
            beam.className = 'jet-beam';
            beam.style.width = length + 'px';
            beam.style.left = x1 + 'px';
            beam.style.top = y1 + 'px';
            beam.style.transform = `translateY(-50%) rotate(${angle}deg)`;

            board.appendChild(beam);

            requestAnimationFrame(() => {
                beam.style.opacity = 1;
                setTimeout(() => {
                    beam.style.opacity = 0;
                    setTimeout(() => { 
                        if(beam.parentNode) beam.remove(); 
                        this.animating = false; 
                    }, 200);
                }, 300);
            });
        }
        
        showResurrectAnimation(idx, callback) {
            this.animating = true;
            const cell = document.getElementById('cell-' + idx);
            if (!cell) {
                this.animating = false;
                if(callback) callback();
                return;
            }

            const soul = document.createElement('div');
            soul.className = 'resurrect-soul';
            soul.innerText = 'üëª';
            
            cell.appendChild(soul);
            
            // Animation lasts 1.2s in CSS
            setTimeout(() => {
                if(soul.parentNode) soul.remove();
                this.animating = false;
                if(callback) callback();
            }, 1200);
        }

        executeJetSkill(idx) {
            const cells = document.getElementById('board').children;
            if(cells[idx].classList.contains('highlight-skill-target')) {
                Sound.jet();
                this.showJetAnimation(this.selectedIdx, idx);

                setTimeout(() => {
                    const victim = this.board[idx];
                    this.addToGraveyard(victim);
                    this.board[idx] = null;
                    this.board[this.selectedIdx].charge = 0;
                    this.render();
                    this.endTurn();
                }, 400); 
                
            } else {
                const p = this.board[idx];
                if (p && p.revealed && p.r === 7) {
                    Sound.fail();
                    this.showMsg("BOSSÂÖçÁñ´Ê∞¥Êü±ÔºÅ");
                } else {
                    Sound.error();
                }
            }
        }

        executeMove(from, to) {
            const p = this.board[from];
            if(p.isFF && p.charge < 3) p.charge++;
            this.board[to] = p;
            this.board[from] = null;
            Sound.move();
            this.render();
            this.endTurn();
        }

        executeAttack(from, to, isDark) {
            const attacker = this.board[from];
            if(attacker.isFF && attacker.charge < 3) attacker.charge++;

            if(isDark) {
                const target = this.board[to];
                target.revealed = true;
                this.render(); 

                if(target.color === attacker.color) {
                    Sound.fail();
                    this.showMsg("ÊòØËá™Â∑±‰∫∫");
                    setTimeout(() => this.endTurn(), 500);
                    return;
                }

                let canKill = this.canPieceKill(attacker, target);
                if(canKill) {
                    setTimeout(() => this.performCapture(from, to), 500);
                } else {
                    Sound.fail();
                    this.shakePiece(from);
                    this.showMsg("Êâì‰∏çÈÅé");
                    setTimeout(() => this.endTurn(), 500);
                }
            } else {
                this.performCapture(from, to);
            }
        }

        performCapture(from, to) {
            const victim = this.board[to];
            const killer = this.board[from];
            this.addToGraveyard(victim);
            Sound.capture();
            this.board[to] = killer;
            this.board[from] = null;
            this.render();
            this.startChainCapture(to);
        }

        startChainCapture(idx) {
            if(this.hasTargets(idx)) {
                this.isChainCapturing = true;
                this.chainIdx = idx;
                this.selectedIdx = idx;
                this.render();
                this.highlightTargets(idx, true);
                document.getElementById('btn-end-capture').style.display = 'flex';
                this.showMsg("ÈÄ£ÂêÉÔºÅ");
            } else {
                setTimeout(() => this.endTurn(), 300);
            }
        }

        hasTargets(idx) {
            for(let i=0; i<32; i++) {
                if(i===idx) continue;
                const res = this.checkAttack(idx, i);
                if(res.reachable && (res.valid || res.isDark)) return true;
            }
            return false;
        }

        canPieceKill(attacker, target) {
            if(attacker.isFF) {
                if(target.r === 7) return false; 
                return true; 
            }
            if(target.isFF) {
                if(attacker.r === 7) return true; 
                if(attacker.r === 1) return false; 
                if(attacker.r === 2) return true; 
                return false; 
            }
            if(attacker.r === 2) return true; 
            if(attacker.r === 7 && target.r === 1) return false; 
            if(attacker.r === 1 && target.r === 7) return true; 
            return attacker.r >= target.r;
        }

        checkAttack(from, to) {
            const attacker = this.board[from];
            const target = this.board[to];
            if(!target) return {reachable:false};

            const isDark = !target.revealed;
            const dist = this.getDist(from, to);
            let reachable = false;

            if(attacker.r === 2) { 
                const x1=from%4, y1=Math.floor(from/4);
                const x2=to%4, y2=Math.floor(to/4);
                if(x1===x2 || y1===y2) {
                    let screens = 0;
                    const minX=Math.min(x1,x2), maxX=Math.max(x1,x2);
                    const minY=Math.min(y1,y2), maxY=Math.max(y1,y2);
                    if(y1===y2) { for(let k=minX+1;k<maxX;k++) if(this.board[y1*4+k]) screens++; }
                    else { for(let k=minY+1;k<maxY;k++) if(this.board[k*4+x1]) screens++; }
                    if(screens === 1) reachable = true;
                }
            } else {
                if(dist === 1) reachable = true;
            }

            if(!reachable) return {reachable:false};
            if(isDark) return {reachable:true, valid:true, isDark:true};
            if(target.color === attacker.color) return {reachable:true, valid:false, isDark:false};

            return {reachable:true, valid:this.canPieceKill(attacker, target), isDark:false};
        }

        getDist(i1, i2) { return Math.abs((i1%4)-(i2%4)) + Math.abs(Math.floor(i1/4)-Math.floor(i2/4)); }
        isAdjacent(i1, i2) { return this.getDist(i1, i2) === 1; }
        shakePiece(idx) { const el = document.getElementById(`piece-${idx}`); if(el) { el.classList.remove('fail-shake'); void el.offsetWidth; el.classList.add('fail-shake'); } }

        addToGraveyard(p) {
            const div = document.createElement('div');
            div.className = `graveyard-piece ${p.color} ${p.isFF ? 'ff-dead' : ''}`;
            if (p.isFF) { div.innerText = p.color === 'red' ? 'üë®‚Äçüöí' : 'ü•∑'; } 
            else { div.innerText = p.n; }
            if(p.color === 'red') document.getElementById('graveyard-red-strip').appendChild(div);
            else document.getElementById('graveyard-black-strip').appendChild(div);
        }

        highlightTargets(idx, isChain=false) {
            const cells = document.getElementById('board').children;
            for(let i=0; i<32; i++) {
                if(i===idx) continue;
                const p = this.board[i];
                if(!p) {
                    if(!isChain && this.isAdjacent(idx, i)) cells[i].classList.add('highlight-move');
                    continue;
                }
                const res = this.checkAttack(idx, i);
                if(res.reachable) {
                    if(res.isDark) cells[i].classList.add('highlight-dark-attack');
                    else if(res.valid) cells[i].classList.add('highlight-capture');
                }
            }
        }

        resetControls() {
            document.getElementById('btn-skill-jet').style.display = 'none';
            document.getElementById('btn-pawn-swap').style.display = 'none';
            document.getElementById('btn-pawn-rez').style.display = 'none';
            document.getElementById('btn-pawn-equip').style.display = 'none';
            document.getElementById('btn-cancel').style.display = 'none';
            document.getElementById('btn-end-capture').style.display = 'none';
        }

        cancelAction() {
            this.selectedIdx = -1;
            this.skillMode = null;
            this.resetControls();
            this.render();
        }

        endTurn() {
            this.selectedIdx = -1;
            this.isChainCapturing = false;
            this.chainIdx = -1;
            this.skillMode = null;
            this.turn = (this.turn === 'red') ? 'black' : 'red';
            this.updateUI();
            this.resetControls();
            this.render();
            this.checkWin();
        }

        updateUI(msg) {
            const disp = document.getElementById('turn-display');
            disp.innerText = msg || (this.turn === 'red' ? 'Á¥ÖÊñπÂõûÂêà' : 'ÈªëÊñπÂõûÂêà');
            disp.className = 'turn-indicator';
            if(this.turn === 'red') disp.classList.add('active-red');
            if(this.turn === 'black') disp.classList.add('active-black');
        }

        showMsg(txt) {
            const el = document.getElementById('message-overlay');
            el.innerText = txt;
            el.style.opacity = 1;
            setTimeout(()=>el.style.opacity=0, 1000);
        }

        checkWin() {
            let r=0, b=0;
            this.board.forEach(p => { if(p) p.color==='red' ? r++ : b++; });
            if(r===0 || b===0) {
                this.gameOver = true;
                document.getElementById('winner-title').innerText = r===0 ? "ÈªëÊñπÁç≤ÂãùÔºÅ" : "Á¥ÖÊñπÁç≤ÂãùÔºÅ";
                document.getElementById('game-over-screen').classList.remove('hidden-screen');
                Sound.win();
            }
        }
    }

    const game = new DarkChess();
</script>
</body>
</html>